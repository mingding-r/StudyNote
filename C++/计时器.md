#### 重传计时器(Retransmission Timer)：

目的：为了控制丢失的报文段或者丢弃的报文段。这段时间为对报文段的等待确认时间。

创建时间：在TCP发送报文段时，会创建对次特定报文段的重传计时器。

可能发生的两种情况：在截止时间（通常为60秒）到之前，已经收到了对此特定报文段的确认，则撤销计时器；在截止时间到了，但为收到对此特定报文段的确认，则重传报文段，并且将计时器复位。

重传时间：2*RTT（Round Trip Time，为往返时间）

#### 坚持计时器(Persistent Timer)：

目的：主要解决零窗口大小通知可能导致的死锁问题

死锁问题的产生：当接收端的窗口大小为0时，接收端向发送端发送一个零窗口报文段，发送端即停止向对端发送数据。此后，如果接收端缓存区有空间则会重新给发送端发送一个窗口大小，即窗口更新。但接收端发送的这个确认报文段有可能会丢失，而此时接收端不知道已经丢失并认为自己已经发送成功，则一直处于等待数据的状态；而发送端由于没有收到该确认报文段，就会一直等待对方发来新的窗口大小，这样一来，双方都处在等待对方的状态，这样就形成了一种死锁问题。如果没有应对措施，这种局面是不会被打破的。为了解决这种问题，TCP为每一个连接设置了坚持计时器。

工作原理：当发送端TCP收到接收端发来的零窗口通知时，就会启动坚持计时器。当计时器的期限到达时，发送端就会主动发送一个特殊的报文段告诉对方确认已经丢失，必须重新发送。【这个特殊的报文段就称为探测报文段，探测报文段只有1个字节的大小，里边只有一个序号，该序号不需要被确认，甚至在计算其他部分数据的确认时该序号会被忽略。】

截止期的设置：设置为重传时间的值。但如果没有收到接收端的响应，则会发送另一个探测报文段，并将计时器的值加倍并复位，直到大于门限值（一般为60秒）。在此之后，发送端会每隔60秒发送一个探测报文段，直到窗口重新打开。

#### 保活计时器(Keeplive Timer)：

目的：主要是为了防止两个TCP连接出现长时间的空闲。当客户端与服务器端建立TCP连接后，很长时间内客户端都没有向服务器端发送数据，此时很有可能是客户端出现故障，而服务器端会一直处于等待状态。保活计时器就是解决这种问题而生的。

工作原理：每当服务器端收到客户端的数据时，都将保活计时器重新设置（通常设置为2小时）。过了2小时后，服务器端如果没有收到客户端的数据，会发送探测报文段给客户端，并且每隔75秒发送一个，当连续发送10次以后，仍没有收到对端的来信，则服务器端认为客户端出现故障，并会终止连接。

#### 时间等待计时器(Time_Wait Timer)：

时间等待计时器是在连接终止期间使用的。

当TCP关闭连接时并不是立即关闭的，在等待期间，连接还处于过渡状态。这样就可以使重复的FIN报文段在到达终点之后被丢弃。

时间设置：一般为报文段寿命期望值的2倍。

#### 补充：2MSL计时器：

在讲该计时器之前，我们先来了解一下TCP是怎样断开连接的，这种方式也成为“四次挥手”

![img](https://img-blog.csdn.net/20170306125032413?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzM5NTExODA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

MSL(Maximum Segment Lifetime)即报文段最大生存时间

TCP的TIME_WAIT状态也称为2MSL等待状态。当TCP一端主动发起关闭请求后会使用“四次挥手”的方式最终断开连接。当发出最后一个ACK字段后也就是第三次挥手完成后，发送了第四次的ACK包就进入了TIME_WAIT状态。

等待2MAL时间的目的：如果对方没有收到最后一个ACK字段，则会在超时后重发第三次挥手的FIN字段，主动关闭方接到重传的FIN字段会重新发送ACK。处在TIME_WAIT状态的两端端口都不能使用，等到2MSL时间结束后才能继续使用。当连接处于2MSL等待阶段时，任何迟到的报文段将会被丢弃。这样一来，就会有更大的机会让丢失的ACK字段再次被发送出去，并且也让“四次挥手”更加可靠。

该状态设计在主动关闭方的理由：由主动关闭方发送最后一次ACK字段；只要由一方保持TIME_WAIT状态，就能起到避免连接在2MSL内重新建立，不需要双方都有