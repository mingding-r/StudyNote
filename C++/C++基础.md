# C++基础

## const与#define

#### 一：区别

（1）就起作用的阶段而言： #define是在编译的预处理阶段起作用，而const是在 编译、运行的时候起作用。
（2）就起作用的方式而言： #define只是简单的字符串替换，没有类型检查。而const有对应的数据类型，是要进行判断的，可以避免一些低级的错误。 
（3）就存储方式而言：#define只是进行展开，有多少地方使用，就替换多少次，它定义的宏常量在内存中有若干个备份；const定义的只读变量在程序运行过程中只有一份备份。
（4）从代码调试的方便程度而言： const常量可以进行调试的，define是不能进行调试的，因为在预编译阶段就已经替换掉了。

#### 二：const优点

（1）const常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。
（2）有些集成化的调试工具可以对const常量进行调试，但是不能对宏常量进行调试。
（3）const可节省空间，避免不必要的内存分配，提高效率

#### const


**1、定义常量**
(1)const修饰变量，以下两种定义形式在本质上是一样的。它的含义是：const修饰的类型为TYPE的变量value是不可变的。

TYPE const ValueName = value;
const TYPE ValueName = value;

(2)将const改为外部连接,作用于扩大至全局,编译时会分配内存,并且可以不进行初始化,仅仅作为声明,编译器认为在程序其他地方进行了定义.

```
 extend const int ValueName = value;
1
```

**2、指针使用CONST**
(1)指针本身是常量不可变
char* const pContent;

(2)指针所指向的内容是常量不可变
const char *pContent;

(3)两者都不可变
const char* const pContent;

(4)还有其中区别方法，沿着*号划一条线：
如果const位于*的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；
如果const位于*的右侧，const就是修饰指针本身，即指针本身是常量。

**3、函数中使用CONST**

(1)const修饰函数参数
a.传递过来的参数在函数内不可以改变(无意义，因为Var本身就是形参)

void function(const int Var);

b.参数指针所指内容为常量不可变

void function(const char* Var);

c.参数指针本身为常量不可变(也无意义，因为char* Var也是形参)

void function(char* const Var);

d.参数为引用，为了增加效率同时防止修改。修饰引用参数时：

void function(const Class& Var); //引用参数在函数内不可以改变

void function(const TYPE& Var); //引用参数在函数内为常量不可变

这样的一个const引用传递和最普通的函数按值传递的效果是一模一样的,他禁止对引用的对象的一切修改,唯一不同的是按值传递会先建立一个类对象的副本, 然后传递过去,而它直接传递地址,所以这种传递比按值传递更有效.另外只有引用的const传递可以传递一个临时对象,因为临时对象都是const属性, 且是不可见的,他短时间存在一个局部域中,所以不能使用指针,只有引用的const传递能够捕捉到这个家伙.

(2)const 修饰函数返回值
const修饰函数返回值其实用的并不是很多，它的含义和const修饰普通变量以及指针的含义基本相同。
a.const int fun1() //这个其实无意义，因为参数返回本身就是赋值。
b. const int * fun2() //调用时 const int *pValue = fun2();
//我们可以把fun2()看作成一个变量，即指针内容不可变。
c.int* const fun3() //调用时 int * const pValue = fun2();
//我们可以把fun2()看作成一个变量，即指针本身不可变。

一般情况下，函数的返回值为某个对象时，如果将其声明为const时，多用于操作符的重载。通常，不建议用const修饰函数的返回值类型为某个对象或对某个对象引用的情况。原因如下：如果返回值为某个对象为const（const A test = A 实例）或某个对象的引用为const（const A& test = A实例） ，则返回值具有const属性，则返回实例只能访问类A中的公有（保护）数据成员和const成员函数，并且不允许对其进行赋值操作，这在一般情况下很少用到。

4、类相关CONST

(1)const修饰成员变量
const修饰类的成员函数，表示成员常量，不能被修改，同时它只能在初始化列表中赋值。
class A
{
…
const int nValue; //成员常量不能被修改
…
A(int x): nValue(x) { } ; //只能在初始化列表中赋值
}

(2)const修饰成员函数
const修饰类的成员函数，则该成员函数不能修改类中任何非const成员函数。一般写在函数的最后来修饰。
class A
{
…
void function()const; //常成员函数, 它不改变对象的成员变量.

//也不能调用类中任何非const成员函数。
}

对于const类对象/指针/引用，只能调用类的const成员函数，因此，const修饰成员函数的最重要作用就是限制对于const对象的使用。

a. const成员函数不被允许修改它所在对象的任何一个数据成员。

b. const成员函数能够访问对象的const成员，而其他成员函数不可以。

(3)const修饰类对象/对象指针/对象引用

· const修饰类对象表示该对象为常量对象，其中的任何成员都不能被修改。对于对象指针和对象引用也是一样。

· const修饰的对象，该对象的任何非const成员函数都不能被调用，因为任何非const成员函数会有修改成员变量的企图。
例如：
class AAA
{
void func1();
void func2() const;
}
const AAA aObj;
aObj.func1(); ×
aObj.func2(); 正确

const AAA* aObj = new AAA();
aObj-> func1(); ×
aObj-> func2(); 正确

三、将Const类型转化为非Const类型的方法

采用const_cast 进行转换。
用法：const_cast (expression)
该运算符用来修改类型的const或volatile属性。除了const 或volatile修饰之外， type_id和expression的类型是一样的。

· 常量指针被转化成非常量指针，并且仍然指向原来的对象；

· 常量引用被转换成非常量引用，并且仍然指向原来的对象；

· 常量对象被转换成非常量对象。

## c++11新特性

### 1.1 auto关键字

auto并没有让C++成为弱类型语言，也没有弱化变量什么，只是**使用auto的时候，编译器根据上下文情况，确定auto变量的真正类型。**

auto在C++14中可以作为函数的返回值。

auto作为函数返回值时，只能用于定义函数，不能用于声明函数。

### 1.2、nullptr关键字及用法

引入nullptr关键字是为了解决NULL表示空指针在C++中具有二义性的问题。

因为C++是强类型语言，void是不能隐式转换成其他类型的指针的。因此c++中，为了解决空指针的表示问题，C++引入了0来表示空指针，NULL实际上是0。但是实际上，用NULL代替0表示空指针在函数重载时会出现问题，程序执行的结果会与我们的想法不同。

使用nullptr作为实参，保证选择正确的以void*作为形参的函数版本，避免二义性。

**总结：**

NULL在C++中就是0，这是因为在C++中void* 类型是不允许隐式转换成其他类型的，所以之前C++中用0来代表空指针，但是在重载整形的情况下，会出现上述的问题。所以，C++11加入了nullptr，可以保证在任何情况下都代表空指针，而不会出现上述的情况，因此，建议以后还是都用nullptr替代NULL吧，而NULL就当做0使用。


### 1.3、for循环语法

```
int main()
{
    int numbers[] = { 1,2,3,4,5 };
    std::cout << "numbers:" << std::endl;
    for (auto number : numbers)
    {
        std::cout << number << std::endl;
    }
}
```

### 2、STL容器

std::array、std::forward_list、std::unordered_map、std::unordered_set

### 3、多线程

std::thread、std::atomic、std::condition_variable、

### 4、智能指针内存管理

std::shared_ptr、std::weak_ptr，std::unique_ptr

智能指针只是用对象去管理一个资源指针，同时用一个计数器计算当前指针引用对象的个数，当管理指针的对象增加或减少时，计数器也相应加1或减1，当最后一个指针管理对象销毁时，计数器为1，此时在销毁指针管理对象的同时，也把指针管理对象所管理的指针进行delete操作。

shared_ptr允许多个指针指向同一个对象；unique_ptr则独占所指向的对象。标准库还定义了一个weak_ptr的伴随类，他是一种弱引用，指向shared_ptr所管理的对象。这三种类型都定义在memory头文件中。

#### **shared_ptr**

多个 shared_ptr 对象可以共同托管一个指针 p，当所有曾经托管 p 的 shared_ptr 对象都解除了对其的托管时，就会执行`delete p`。

可以用让多个 shared_ptr 对象托管同一个指针。这多个 shared_ptr 对象会共享一个对共同托管的指针的“托管计数”。有 n 个 shared_ptr 对象托管同一个指针 p，则 p 的托管计数就是 n。当一个指针的托管计数减为 0 时，该指针会被释放。shared_ptr 对象消亡或托管了新的指针，都会导致其原托管指针的托管计数减 1。

shared_ptr 的 reset 成员函数可以使得对象解除对原托管指针的托管（如果有的话），并托管新的指针。原指针的托管计数会减 1。

当没有 shared_ptr 对象托管 A(2)，于是 A(2) 的托管计数变为 0。最后一个解除对 A(2) 托管的 shared_ptr 对象会释放 A(2)。

main 函数结束时，sp1、sp2、sp3 对象消亡，各自将其托管的指针的托管计数减为 0，并且释放其托管的指针，

只有指向动态分配的对象的指针才能交给 shared_ptr 对象托管。将指向普通局部变量、全局变量的指针交给 shared_ptr 托管，编译时不会有问题，但程序运行时会出错，因为不能析构一个并没有指向动态分配的内存空间的指针。

注意，不能用下面的方式使得两个 shared_ptr 对象托管同一个指针：

```c++
A* p = new A(10);
shared_ptr <A> sp1(p), sp2(p);
```

sp1 和 sp2 并不会共享同一个对 p 的托管计数，而是各自将对 p 的托管计数都记为 1（sp2 无法知道 p 已经被 sp1 托管过）。这样，当 sp1 消亡时要析构 p，sp2 消亡时要再次析构 p，这会导致程序崩溃。

**目的：状态共享**

使用shared_ptr在一个常见的原因是允许多个多个对象共享相同的状态，而非多个对象独立的拷贝！

**总结：**

　　最后总结一下上面所陈述的内容，也是shared_ptr使用的基本规范

1）不使用相同的内置指针值初始化（或reset）多个智能指针。

2）不delete get函数返回的指针。

3）如果你使用了get返回的指针，记住当最后一个对应的智能指针销毁后，你的指针就变为无效了。

4）如果你使用智能指针管理的资源不是new分配的内存，记得传递给他一个删除器。

问题：若存在循环引用则会导致内存泄漏。

#### **weak_ptr**

weak_ptr是为了配合shared_ptr而引入的一种智能指针，它指向一个由shared_ptr管理的对象而不影响所指对象的生命周期，也就是将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数。不论是否有weak_ptr指向，一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放。从这个角度看，weak_ptr更像是shared_ptr的一个助手而不是智能指针。

**如何判断weak_ptr指向对象是否存在**

既然weak_ptr并不改变其所共享的shared_ptr实例的引用计数，那就可能存在weak_ptr指向的对象被释放掉这种情况。这时，我们就不能使用weak_ptr直接访问对象。那么我们如何判断weak_ptr指向对象是否存在呢？C++中提供了lock函数来实现该功能。如果对象存在，lock()函数返回一个指向共享对象的shared_ptr，否则返回一个空shared_ptr。

## new与malloc的区别

### 1. 申请的内存所在位置

new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。

那么自由存储区是否能够是堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存。

特别的，new甚至可以不为对象分配内存！定位new的功能可以办到这一点：

```
new (place_address) type
```

place_address为一个指针，代表一块内存的地址。当使用上面这种仅以一个地址调用new操作符时，new操作符调用特殊的operator new，也就是下面这个版本：

```
void * operator new (size_t,void *) //不允许重定义这个版本的operator new
```

这个operator new不分配任何的内存，它只是简单地返回指针实参，然后右new表达式负责在place_address指定的地址进行对象的初始化工作。

### 2.返回类型安全性

new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。
类型安全很大程度上可以等价于内存安全，类型安全的代码不会试图方法自己没被授权的内存区域。关于C++的类型安全性可说的又有很多了。

### 3.内存分配失败时的返回值

new内存分配失败时，会抛出bac_alloc异常，它不会返回NULL；malloc分配内存失败时返回NULL。
在使用C语言时，我们习惯在malloc分配内存后判断分配是否成功：

```
int *a  = (int *)malloc ( sizeof (int ));
if(NULL == a)
{
    ...
}
else 
{
    ...
}
```

从C语言走入C++阵营的新手可能会把这个习惯带入C++：

```
int * a = new int();
if(NULL == a)
{
    ...
}
else
{   
    ...
}
```

实际上这样做一点意义也没有，因为new根本不会返回NULL，而且程序能够执行到if语句已经说明内存分配成功了，如果失败早就抛异常了。正确的做法应该是使用异常机制：

```
try
{
    int *a = new int();
}
catch (bad_alloc)
{
    ...
}
```

如果你想顺便了解下异常基础，可以看http://www.cnblogs.com/QG-whz/p/5136883.htmlC++ 异常机制分析。

### 4.是否需要指定内存大小

使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而malloc则需要显式地指出所需内存的尺寸。

```
class A{...}
A * ptr = new A;
A * ptr = (A *)malloc(sizeof(A)); //需要显式指定所需内存大小sizeof(A);
```

当然了，我这里使用malloc来为我们自定义类型分配内存是不怎么合适的，请看下一条。

### 5.是否调用构造函数/析构函数

使用new操作符来分配对象内存时会经历三个步骤：

- 第一步：调用operator new 函数（对于数组是operator new[]）分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象。
- 第二步：编译器运行相应的构造函数以构造对象，并为其传入初值。
- 第三部：对象构造完成后，返回一个指向该对象的指针。

使用delete操作符来释放对象内存时会经历两个步骤：

- 第一步：调用对象的析构函数。
- 第二步：编译器调用operator delete(或operator delete[])函数释放内存空间。

总之来说，new/delete会调用对象的构造函数/析构函数以完成对象的构造/析构。而malloc则不会。如果你不嫌啰嗦可以看下我的例子：

```
class A
{
public:
    A() :a(1), b(1.11){}
private:
    int a;
    double b;
};
int main()
{
    A * ptr = (A*)malloc(sizeof(A));
    return 0;
}
```

在return处设置断点，观看ptr所指内存的内容：

可以看出A的默认构造函数并没有被调用，因为数据成员a,b的值并没有得到初始化，这也是上面我为什么说使用malloc/free来处理C++的自定义类型不合适，其实不止自定义类型，标准库中凡是需要构造/析构的类型通通不合适。

而使用new来分配对象时：

```
int main()
{
    A * ptr = new A;
}
```

查看程序生成的汇编代码可以发现，A的默认构造函数被调用了：

### 6.对数组的处理

C++提供了new[]与delete[]来专门处理数组类型:

```
A * ptr = new A[10];//分配10个A对象
```

使用new[]分配的内存必须使用delete[]进行释放：

```
delete [] ptr;
```

new对数组的支持体现在它会分别调用构造函数函数初始化每一个数组元素，释放对象时为每个对象调用析构函数。注意delete[]要与new[]配套使用，不然会找出数组对象部分释放的现象，造成内存泄漏。

至于malloc，它并知道你在这块内存上要放的数组还是啥别的东西，反正它就给你一块原始的内存，在给你个内存的地址就完事。所以如果要动态分配一个数组的内存，还需要我们手动自定数组的大小：

```
int * ptr = (int *) malloc( sizeof(int) );//分配一个10个int元素的数组
```

### 7.new与malloc是否可以相互调用

operator new /operator delete的实现可以基于malloc，而malloc的实现不可以去调用new。下面是编写operator new /operator delete 的一种简单方式，其他版本也与之类似：

```
void * operator new (sieze_t size)
{
    if(void * mem = malloc(size)
        return mem;
    else
        throw bad_alloc();
}
void operator delete(void *mem) noexcept
{
    free(mem);
}
```

### 8.是否可以被重载

operator new /operator delete可以被重载。标准库是定义了operator new函数和operator delete函数的8个重载版本：

```
//这些版本可能抛出异常
void * operator new(size_t);
void * operator new[](size_t);
void * operator delete (void * )noexcept;
void * operator delete[](void *0）noexcept;
//这些版本承诺不抛出异常
void * operator new(size_t ,nothrow_t&) noexcept;
void * operator new[](size_t, nothrow_t& );
void * operator delete (void *,nothrow_t& )noexcept;
void * operator delete[](void *0,nothrow_t& ）noexcept;
```

我们可以自定义上面函数版本中的任意一个，前提是自定义版本必须位于全局作用域或者类作用域中。太细节的东西不在这里讲述，总之，我们知道我们有足够的自由去重载operator new /operator delete ,以决定我们的new与delete如何为对象分配内存，如何回收对象。

而malloc/free并不允许重载。

### 9. 能够直观地重新分配内存

使用malloc分配的内存后，如果在使用过程中发现内存不足，可以使用realloc函数进行内存重新分配实现内存的扩充。realloc先判断当前的指针所指内存是否有足够的连续空间，如果有，原地扩大可分配的内存地址，并且返回原来的地址指针；如果空间不够，先按照新指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来的内存区域。

new没有这样直观的配套设施来扩充内存。

### 10. 客户处理内存分配不足

在operator new抛出异常以反映一个未获得满足的需求之前，它会先调用一个用户指定的错误处理函数，这就是new-handler。new_handler是一个指针类型：

```
namespace std
{
    typedef void (*new_handler)();
}
```

指向了一个没有参数没有返回值的函数,即为错误处理函数。为了指定错误处理函数，客户需要调用set_new_handler，这是一个声明于的一个标准库函数:

```
namespace std
{
    new_handler set_new_handler(new_handler p ) throw();
}
```

set_new_handler的参数为new_handler指针，指向了operator new 无法分配足够内存时该调用的函数。其返回值也是个指针，指向set_new_handler被调用前正在执行（但马上就要发生替换）的那个new_handler函数。

对于malloc，客户并不能够去编程决定内存不足以分配时要干什么事，只能看着malloc返回NULL。

### 总结

将上面所述的10点差别整理成表格：

|        特征        |              new/delete               |             malloc/free              |
| :----------------: | :-----------------------------------: | :----------------------------------: |
|   分配内存的位置   |              自由存储区               |                  堆                  |
| 内存分配失败返回值 |             完整类型指针              |                void*                 |
| 内存分配失败返回值 |             默认抛出异常              |               返回NULL               |
|   分配内存的大小   |       由编译器根据类型计算得出        |          必须显式指定字节数          |
|      处理数组      |       有处理数组的new版本new[]        | 需要用户计算数组的大小后进行内存分配 |
|  已分配内存的扩充  |            无法直观地处理             |         使用realloc简单完成          |
|    是否相互调用    | 可以，看具体的operator new/delete实现 |             不可调用new              |
| 分配内存时内存不足 | 客户能够指定处理函数或重新制定分配器  |       无法通过用户代码进行处理       |
|      函数重载      |                 允许                  |                不允许                |
| 构造函数与析构函数 |                 调用                  |                不调用                |

new从自由存储区上分配内存，malloc从堆上分配内存；new/delete会调用构造函数/析构函数对对象进行初始化与销毁；operator new/delete可以进行重载；然后强行分析了一下自由存储区与堆的区别。

在C++中，内存区分为5个区，分别是堆、栈、自由存储区、全局/静态存储区、常量存储区”

malloc在堆上分配的内存块，使用free释放内存，而new所申请的内存则是在自由存储区上，使用delete来释放。

**堆是操作系统维护的一块内存，而自由存储是C++中通过new与delete动态分配和释放对象的抽象概念。堆与自由存储区并不等价。**

## 堆和栈究竟有什么区别？

  主要的区别由以下几点：

  1、管理方式不同；

  2、空间大小不同；

  3、能否产生碎片不同；

  4、生长方向不同；

  5、分配方式不同；

  6、分配效率不同；

管理方式：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。

    空间大小：一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，例如，在VC6下面，默认的栈空间大小是1M（好像是，记不清楚了）。当然，我们可以修改：
    
    打开工程，依次操作菜单如下：Project->Setting->Link，在Category 中选中Output，然后在Reserve中设定堆栈的最大值和commit。

注意：reserve最小值为4Byte；commit是保留在虚拟内存的页文件里面，它设置的较大会使栈开辟较大的值，可能增加内存的开销和启动时间。

    堆和栈相比，由于大量new/delete的使用，容易造成大量的内存碎片；由于没有专门的系统支持，效率很低；由于可能引发用户态和核心态的切换，内存的申请，代价变得更加昂贵。所以栈在程序中是应用最广泛的，就算是函数的调用也利用栈去完成，函数调用过程中的参数，返回地址，EBP和局部变量都采用栈的方式存放。所以，我们推荐大家尽量用栈，而不是用堆。
### static用来控制变量的存储方式和可见性

       函数内部定义的变量，在程序执行到它的定义处时，编译器为它在栈上分配空间，函数在栈上分配的空间在此函数执行结束时会释放掉，这样就产生了一个问题: 如果想将函数中此变量的值保存至下一次调用时，如何实现？ 最容易想到的方法是定义一个全局的变量，但定义为一个全局变量有许多缺点，最明显的缺点是破坏了此变量的访问范围（使得在此函数中定义的变量，不仅仅受此函数控制）。
    
       需要一个数据对象为整个类而非某个对象服务,同时又力求不破坏类的封装性,即要求此成员隐藏在类的内部，对外不可见。
    
       static的内部机制：
    
       静态数据成员要在程序一开始运行时就必须存在。因为函数在程序运行中被调用，所以静态数据成员不能在任何函数内分配空间和初始化。
    
       这样，它的空间分配有三个可能的地方，一是作为类的外部接口的头文件，那里有类声明；二是类定义的内部实现，那里有类的成员函数定义；三是应用程序的main（）函数前的全局数据声明和定义处。
    
      静态数据成员要实际地分配空间，故不能在类的声明中定义（只能声明数据成员）。类声明只声明一个类的“尺寸和规格”，并不进行实际的内存分配，所以在类声明中写成定义是错误的。它也不能在头文件中类声明的外部定义，因为那会造成在多个使用该类的源文件中，对其重复定义。
    
      static被引入以告知编译器，将变量存储在程序的静态存储区而非栈上空间，静态数据成员按定义出现的先后顺序依次初始化，注意静态成员嵌套时，要保证所嵌套的成员已经初始化了。消除时的顺序是初始化的反顺序。
    
       static的优势：
    
       可以节省内存，因为它是所有对象所公有的，因此，对多个对象来说，静态数据成员只存储一处，供所有对象共用。静态数据成员的值对每个对象都是一样，但它的值是可以更新的。只要对静态数据成员的值更新一次，保证所有对象存取更新后的相同的值，这样可以提高时间效率。
    
        引用静态数据成员时，采用如下格式：
    
        <类名>::<静态成员名>
    
    如果静态数据成员的访问权限允许的话(即public的成员)，可在程序中，按上述格式

来引用静态数据成员。

       PS:
    
      (1)类的静态成员函数是属于整个类而非类的对象，所以它没有this指针，这就导致

了它仅能访问类的静态数据和静态成员函数。

      (2)不能将静态成员函数定义为虚函数。
    
      (3)由于静态成员声明于类中，操作于其外，所以对其取地址操作，就多少有些特殊

，变量地址是指向其数据类型的指针 ，函数地址类型是一个“nonmember函数指针”。

      (4)由于静态成员函数没有this指针，所以就差不多等同于nonmember函数，结果就

产生了一个意想不到的好处：成为一个callback函数，使得我们得以将C++和C-based X Window系统结合，同时也成功的应用于线程函数身上。

      (5)static并没有增加程序的时空开销，相反她还缩短了子类对父类静态成员的访问

时间，节省了子类的内存空间。

      (6)静态数据成员在<定义或说明>时前面加关键字static。
    
      (7)静态数据成员是静态存储的，所以必须对它进行初始化。
    
      (8)静态成员初始化与一般数据成员初始化不同:
    
      初始化在类体外进行，而前面不加static，以免与一般静态变量或对象相混淆；
    
      初始化时不加该成员的访问权限控制符private，public等；
    
          初始化时使用作用域运算符来标明它所属类；
    
          所以我们得出静态数据成员初始化的格式：
    
         <数据类型><类名>::<静态数据成员名>=<值>
    
      (9)为了防止父类的影响，可以在子类定义一个与父类相同的静态变量，以屏蔽父类的影响。这里有一点需要注意：我们说静态成员为父类和子类共享，但我们又重复定义了静态成员，这会不会引起错误呢？不会，我们的编译器采用了一种绝妙的手法：name-mangling 用以生成唯一的标志。

补充：new delete［］,基本类型的对象没有析构函数（例如 int , char ），所以回收基本类型组成的数组空间 delete delete[] 都是应该可以如： int p= new int[10], delete p 和delete[]p 都可以。但是对于类对象数组（如string strArr = new string[10]），只能 delete[]。对 new 的单个对象，只能delete 不能 delete[] 回收空间。

## vector中的resize，reserve

### 前言

在介绍resize()，reserve()，size()和capacity()函数之前，先简单介绍一下c++中vector的概念。

vector：顺序容器（可变大小数组）。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢。

既然vector是个容器，那么一定相关特性，如添加元素、删除元素和查询容器大小等操作。本文重点介绍vector中的resize()，reserve()，size()和capacity()函数。

### 基本概念

1.capacity

指容器在分配新的存储空间之前能存储的元素总数。

2.size

指当前容器所存储的元素个数

注：capacity是容器可存储的最大总数，size是当前容器存储的个数。还不理解，看我画的图（画风虽怪，但言简意赅）。



1.resize
既分配了空间，也创建了对象。

这里空间就是capacity，对象就是容器中的元素。

2.reserve
reserve()表示容器预留空间，但不是真正的创建对象，需要通过insert()或push_back()等操作创建对象。

其实size()和capacity()没有更多需要介绍的地方，大家平时coding时直接调用即可。当然size()的使用频率相当高，通常进行遍历操作时，最外层的for循环的次数即为size()。resize和reverse

### 区别

1. reserve()只修改capacity大小，不修改size大小，
2. resize()既修改capacity大小，也修改size大小。

#### 总结

- size()：返回vector中的元素个数
- capacity()：返回vector能存储元素的总数
- resize()操作：创建指定数量的的元素并指定vector的存储空间
- reserve()操作：指定vector的元素总数

# 浅拷贝和深拷贝的区别？

概述：

 -浅拷贝可以使用列表自带的copy()函数（如list.copy()），或者使用copy模块的copy()函数。深拷贝只能使用copy模块的deepcopy(),所以使用前要导入：from copy import deepcopy
 -如果拷贝的对象里的元素只有值，没有引用，那浅拷贝和深拷贝没有差别，都会将原有对象复制一份，产生一个新对象，对新对象里的值进行修改不会影响原有对象，新对象和原对象完全分离开。
 -如果拷贝的对象里的元素包含引用（像一个列表里储存着另一个列表，存的就是另一个列表的引用），那浅拷贝和深拷贝是不同的，浅拷贝虽然将原有对象复制一份，但是依然保存的是引用，所以对新对象里的引用里的值进行修改，依然会改变原对象里的列表的值，新对象和原对象完全分离开并没有完全分离开。而深拷贝则不同，它会将原对象里的引用也新创建一个，即新建一个列表，然后放的是新列表的引用，这样就可以将新对象和原对象完全分离开。

## 什么是继承和派生？

在 C++ 中，当定义一个新的类 B 时，如果发现类 B 拥有某个已写好的类 A 的全部特点，此外还有类 A 没有的特点，那么就不必从头重写类 B，而是可以把类 A 作为一个“基类”（也称“父类”），把类 B 写为基类 A 的一个“派生类”（也称“子类”）。这样，就可以说从类 A “派生”出了类 B，也可以说类 B “继承”了类 A。

派生类是通过对基类进行扩充和修改得到的。基类的所有成员自动成为派生类的成员。

所谓扩充，指的是在派生类中可以添加新的成员变量和成员函数；所谓修改，指的是在派生类中可以重写从基类继承得到的成员。

派生类的成员函数不能访问基类的私有成员。



继承与派生其实是同一过程从不同的角度看，我们将保持已有类的特性而构造新类的过程称为继承，说白了继承的目的就是实现原来设计与代码的重用，希望尽量利用原有的类。然而当新的问题出现，原有程序无法解决或不能完全解决时，需要对原有程序进行改造，在已有类的基础上新增自己的特性而产生新类的过程称为派生。

## 指针和引用的区别？

1. 引用必须被初始化，但是不分配存储空间。指针不声明时初始化，在初始化的时候需要分配存储空间。
2. 引用初始化后不能被改变，指针可以改变所指的对象。
3. **不存在指向空值的引用，但是存在指向空值的指针**。

指针从本质上讲就是存放变量地址的一个变量，在逻辑上是独立的，它可以被改变，包括其所指向的地址的改变和其指向的地址中所存放的数据的改变。

而引用是一个别名，它在逻辑上不是独立的，它的存在具有依附性，所以引用必须在一开始就被初始化，而且其引用的对象在其整个生命周期中是不能被改变的（自始至终只能依附于同一个变量）。

- **指针传递**参数本质上是 **值传递**的方式，它所传递的是一个地址值。值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，即在**栈**中开辟了内存空间以存放由主调函数放进来的 实参的值，从而成为了实参的一个副本。值传递的特点是被调函数对形式参数的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值。

  **即指针传递不会影响原数据。**

- 而在**引用传递**过程中， 被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间 接寻址，即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。

  **即引用传递会改变原数据。**

#### 总结

★相同点：

●都是地址的概念；

指针指向一块内存，它的内容是所指内存的地址；而引用则是某块内存的别名。

★不同点：

●指针是一个实体，而引用仅是个别名；

●引用只能在定义时被初始化一次，之后不可变；指针可变；引用“从一而终”，指针可以“见异思迁”；

●**引用没有const，指针有const，const的指针不可变**；

**●引用不能为空，指针可以为空**；

●“**sizeof 引用**”得到的是所指向的变量(对象)的大小，而“**sizeof 指针**”得到的是指针本身的大小；

●指针和引用的自增(++)运算意义不一样；

●引用是类型安全的，而指针不是 (引用比指针多了类型检查）

## 介绍一下你对虚函数的了解

理解：

定义一个函数为虚函数，不代表函数为不被实现的函数。

定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。

定义一个函数为纯虚函数，才代表函数没有被实现。

定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。

一个类函数的调用并不是在编译时刻被确定的，而是在运行时刻被确定的。由于编写代码的时候并不能确定被调用的是基类的函数还是哪个派生类的函数，所以被成为“虚”函数。

虚函数只能借助于指针或者引用来达到多态的效果。

**纯虚函数**是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0”
　virtual void funtion1()=0
**原因：**为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。在很多情况下，基类本身生成对象是不合情理的。

#### 虚函数：

C++中的虚函数的作用主要是实现了多态的机制。基类定义虚函数，子类可以重写该函数；在派生类中对基类定义的虚函数进行重写时，需要在派生类中声明该方法为虚方法。

当子类重新定义了父类的虚函数后，**当父类的指针指向子类对象的地址时**，[即B b; A a = &b;] 父类指针根据赋给它的不同子类指针，动态的调用子类的该函数，而不是父类的函数（如果不使用virtual方法，请看后面★*），且这样的函数调用发生在运行阶段，而不是发生在编译阶段，称为动态联编。而函数的重载可以认为是多态，只不过是静态的。注意，非虚函数静态联编，效率要比虚函数高，但是不具备动态联编能力。

★如果使用了**virtual**关键字，程序将根据引用或指针指向的 **对 象 类 型** 来选择方法，否则使用**引用类型或指针类型**来选择方法。

#### 虚函数的底层实现机制

**实现原理：虚函数表+虚表指针**

**编译器处理虚函数的方法是：**
给每个对象添加一个指针，存放了指向虚函数表的地址，虚函数表存储了为类对象进行声明的虚函数地址。比如基类对象包含一个指针，该指针指向基类所有虚函数的地址表，派生类对象将包含一个指向独立地址表的指针，如果派生类提供了虚函数的新定义，该虚函数表将保存新函数的地址，如果派生类没有重新定义虚函数，该虚函数表将保存函数原始版本的地址。如果派生类定义了新的虚函数，则该函数的地址将被添加到虚函数表中，注意虚函数无论多少个都只需要在对象中添加一个虚函数表的地址。

调用虚函数时，程序将查看存储在对象中的虚函数表地址，转向相应的虚函数表，使用类声明中定义的第几个虚函数，程序就使用数组的第几个函数地址，并执行该函数。

**使用虚函数后的变化：**
（1）	对象将增加一个存储地址的空间（32位系统为4字节，64位为8字节）。
（2）	每个类编译器都创建一个虚函数地址表
（3）	对每个函数调用都需要增加在表中查找地址的操作。

**虚函数的注意事项：**

总结前面的内容
（1） 基类方法中声明了方法为虚后，该方法在基类派生类中是虚的。
（2） 若使用指向对象的引用或指针调用虚方法，程序将根据对象类型来调用方法，而不是指针的类型。
（3）如果定义的类被用作基类，则应将那些要在派生类中重新定义的类方法声明为虚。

#### 析构函数可以使用虚函数么？

构造函数不能为虚函数。
**基类的析构函数应该为虚函数。**（在实现多态时，当用基类操作派生类，在析构时防止只析构基类而不析构派生类的状况发生，以免造成内存泄露）
友元函数不能为虚，因为友元函数不是类成员，只有类成员才能是虚函数。
如果派生类没有重定义函数，则会使用基类版本。
重新定义继承的方法若和基类的方法不同（协变除外），会将基类方法隐藏；如果基类声明方法被重载，则派生类也需要对重载的方法重新定义，否则调用的还是基类的方法。

 如果不需要基类对派生类及对象进行操作,则不能定义虚函数,因为这样会增加内存开销.当类里面有定义虚函数的时候,编译器会给类添加一个虚函数表,里面来存放虚函数指针,这样就会增加类的存储空间.所以,只有当一个类被用来作为基类的时候,才把析构函数写成虚函数.

### **时间复杂度和空间复杂度的定义**

时间复杂度：

> 反映当数据量变化时，操作次数的多少;时间复杂度在评估时，要只保留最高项，并且不要最高项的系数。

空间复杂度：

> 是指算法在计算机内执行时，所需额外开辟的空间。

常数项：

> 与N的大小无关的操作。

#### public,protected,private访问规则

第一：**private, public, protected访问标号的访问范围。**

private：只能由1.该类中的函数、2.其友元函数访问。

不能被任何其他访问，该类的对象也不能访问。

protected：可以被1.该类中的函数、2.子类的函数、以及3.其友元函数访问。

但不能被该类的对象访问。

public：可以被1.该类中的函数、2.子类的函数、3.其友元函数访问，也可以由4.该类的对象访问。

 

注：友元函数包括3种：设为友元的普通的非成员函数；设为友元的其他类的成员函数；设为友元类中的所有成员函数。

第二：**类的继承后方法属性变化。**

private属性不能够被继承。

使用private继承，父类的protected和public属性在子类中变为private；
使用protected继承，父类的protected和public属性在子类中变为protected；
使用public继承，父类中的protected和public属性不发生改变;

如下所示：

|               | public    | protected | private |
| ------------- | --------- | --------- | ------- |
| public继承    | public    | protected | 不可用  |
| protected继承 | protected | protected | 不可用  |
| private继承   | private   | private   | 不可用  |

protected继承和private继承能降低访问权限。

为了进一步理解三种不同的继续方式在其成员的可见性方面的区别，下面从三种不同角度进行讨论。
　　对于公有继续方式：
　　(1) 基类成员对其对象的可见性：
　　公有成员可见，其他不可见。这里保护成员同于私有成员。
　　(2) 基类成员对派生类的可见性：
　　公有成员和保护成员可见，而私有成员不可见。这里保护成员同于公有成员。
　　(3) 基类成员对派生类对象的可见性：
　　公有成员可见，其他成员不可见。
　　所以，在公有继续时，派生类的对象可以访问基类中的公有成员；派生类的成员函数可以访问基类中的公有成员和保护成员。这里，一定要区分清楚派生类的对象和派生类中的成员函数对基类的访问是不同的。
　　对于私有继续方式：
　　(1) 基类成员对其对象的可见性：
　　公有成员可见，其他成员不可见。
　　(2) 基类成员对派生类的可见性：
　　公有成员和保护成员是可见的，而私有成员是不可见的。
　　(3) 基类成员对派生类对象的可见性：
　　所有成员都是不可见的。
　　所以，在私有继续时，基类的成员只能由直接派生类访问，而无法再往下继续。
　　对于保护继续方式：
　　这种继续方式与私有继续方式的情况相同。两者的区别仅在于对派生类的成员而言，对基类成员有不同的可见性。
　　上述所说的可见性也就是可访问性。关于可访问性还有另的一种说法。这种规则中，称派生类的对象对基类访问为水平访问，称派生类的派生类对基类的访问为垂直访问。
　　一般规则如下：
　　公有继续时，水平访问和垂直访问对基类中的公有成员不受限制；
　　私有继续时，水平访问和垂直访问对基类中的公有成员也不能访问；
　　保护继续时，对于垂直访问同于公有继续，对于水平访问同于私有继续。
　　对于基类中的私有成员，只能被基类中的成员函数和友元函数所访问，不能被其他的函数访问。
　　基类与派生类的关系
　　任何一个类都可以派生出一个新类，派生类也可以再派生出新类，因此，基类和派生类是相对而言的。
　　基类与派生类之间的关系可以有如下几种描述：

  　　1. 派生类是基类的具体化
       类的层次通常反映了客观世界中某种真实的模型。在这种情况下，不难看出：基类是对若干个派生类的抽象，而派生类是基类的具体化。基类抽取了它的派生类的公共特征，而派生类通过增加行为将抽象类变为某种有用的类型。
    　　2. 派生类是基类定义的延续
       先定义一个抽象基类，该基类中有些操作并未实现。然后定义非抽象的派生类，实现抽象基类中定义的操作。例如，虚函数就属此类情况。这时，派生类是抽象的基类的实现，即可看成是基类定义的延续。这也是派生类的一种常用方法。
      　　3. 派生类是基类的组合
       在多继承时，一个派生类有多于一个的基类，这时派生类将是所有基类行为的组合。
       　　派生类将其本身与基类区别开来的方法是添加数据成员和成员函数。因此，继承的机制将使得在创建新类时，只需说明新类与已有类的区别，从而大量原有的程序代码都可以复用，所以有人称类是“可复用的软件构件”。


#### static

c++static关键字的作用

c/c++共有

1）：修饰全局变量时，表明一个全局变量只对定义在同一文件中的函数可见。   

2）：修饰局部变量时，表明该变量的值不会因为函数终止而丢失。              

3）：修饰函数时，表明该函数只在同一文件中调用。                      

c++独有：

 4）：修饰类的数据成员，表明对该类所有对象这个数据成员都只有一个实例。即该实例归 所有对象共有。

 5）：用static修饰不访问非静态数据成员的类成员函数。这意味着一个静态成员函数只能访问它的参数、类的静态数据成员和全局变量

##### static的优势：

​        可以节省内存，因为它是所有对象所公有的，因此，对多个对象来说，静态数据成员只存储一处，供所有对象共用。静态数据成员的值对每个对象都是一样，但它的值是可以更新的。只要对静态数据成员的值更新一次，保证所有对象存取更新后的相同的值，这样可以提高时间效率。



#####  静态局部变量

静态局部变量属于静态存储方式，它具有以下特点：

(1)静态局部变量 在函数内定义它的生存期为 整个程序生命周期，但是其 作用域仍与 自动变量相同 ，只能在定义该变量的函数内使用该变量。退出该函数后，尽管该变量还继续存在，但不能使用它。

(2)对基本类型的静态局部变量若在声明时未赋以初值，则系统自动赋予0值 。

##### 静态全局变量

全局变量本身就是静态存储方式，静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同。
这两者的区别在于：

(1).非静态全局变量 的作用域是整个源程序 ，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。

(2). 而静态全局变量 则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于 一个源文件内 ，只能为该源文件内的函数公用， 因此可以避免在其它源文件中引起错误。

从以上分析可以看出，把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围 **static 函数**

##### 静态函数    

 如果在一个源文件中定义的函数，只能被本文件中的函数调用，而不能被同一程序其它文件中的函数调用，这种函数称为static函数与称为静态函数。

内部函数又称静态函数。但此处“static”的含义不是指存储方式，而是指对函数的作用域仅局限于本文件 。

使用内部函数的好处是：不同的人编写不同的函数时，不用担心自己定义的函数，是否会与其它文件中的函数同名，因为同名也没有关系。

##### **static 数据成员**

在类内数据成员的声明前加上关键字static，该数据成员就是类内的静态数据成员。

static数据成员有以下特点：

(1). 对于非static数据成员，每个类对象都有自己的拷贝。而static数据成员被当作是类的成员。无论这个类的对象被定义了多少个，静态数据成员在程序中也只有一份拷贝 ，由该类型的所有对象共享访问。也就是说，静态数据成员是该类的所有对象所共有的。对该类的多个对象来说，静态数据成员只分配一次内存，供所有对象共用。

   (2). 静态数据成员存储在全局数据区。静态数据成员定义时才分配空间，所以不能在类声明中定义。在上例中，语句int Test::m_nSTest1= 10;是定义静态数据成员；

   (3). 静态数据成员和普通数据成员一样遵从public,protected,private访问规则；

   (4). 因为静态数据成员在全局数据区分配内存，属于本类的所有对象共享，所以，它不属于特定的类对象，在没有产生类对象时其作用域就可见，即在没有产生类的实例时，我们就可以操作它；

   (5). 静态数据成员初始化与一般数据成员初始化不同。静态数据成员初始化的格式为：＜数据类型＞＜类名＞::＜静态数据成员名＞=＜值＞ 如：int Test::m_nSTest1 = 10;

(6). 类的静态数据成员有两种访问形式：＜类对象名＞.＜静态数据成员名＞ 或 ＜类类型名＞::＜静态数据成员名＞

(7). 静态数据成员主要用在各个对象都有相同的某项属性的时候。比如对于一个存款类，每个实例的利息都是相同的。所以，应该把利息设为存款类的静态数据成员。这有两个好处，第一，不管定义多少个存款类对象，利息数据成员都共享分配在全局数据区的内存，所以节省存储空间。第二，一旦利息需要改变时，只要改变一次，则所有存款类对象的利息全改变过来了；

(8). 同全局变量相比，使用静态数据成员有两个优势：

a. 静态数据成员没有进入程序的全局名字空间，因此不存在与程序中其它全局名字冲突的可能性；

b. 可以实现信息隐藏。静态数据成员可以是private成员，而全局变量不能；

##### **static成员函数**

关于静态成员函数，可以总结为以下几点：

(1). 出现在类体外的函数定义不能指定关键字static ；

(2). static成员之间可以相互访问 ，包括static成员函数访问static数据成员和访问static成员函数；

(3). 非静态成员函数可以任意地访问静态成员函数和静态数据成员；

(4). 静态成员函数不能访问非静态成员函数和非静态数据成员，只能访问静态的；

(5). 由于没有this指针的额外开销，因此静态成员函数与类的全局函数相比速度上会有少许的增长；

(6). 调用静态成员函数，可以用成员访问操作符(.)和(->)为一个类的对象或指向类对象的指针调用静态成员函数，也可以直接使用如下格式：

＜类名＞::＜静态成员函数名＞（＜参数表＞）

如：Test::PrintStatic()，调用类的静态成员函数。

但是，一样要遵从public,protected,private访问规则。