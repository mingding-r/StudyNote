# map、set与红黑树

## map,set的底层实现

map、set底层是用**红黑树**实现的。

### set（集合）：

包含经过排序了的数据，这些数据的值（value）必须是唯一的。

### map（映射）：

map是STL的一个关联容器，它提供一对一的hash。

第一个可以称为关键字(key)，每个关键字只能在map中出现一次；
第二个可能称为该关键字的值(value)；

map以模板(泛型)方式实现，可以存储任意类型的数据，包括使用者自定义的数据类型。Map主要用于资料一对一映射(one-to-one)的情況，map內部的实现自建一颗红黑树，这颗树具有对数据自动排序的功能。在map内部所有的数据都是有序的。

##### map的功能

自动建立key － value的对应。key 和 value可以是任意你需要的类型。

##### 使用map

使用map得包含map类所在的头文件

\#include <map> //注意，STL头文件没有扩展名.h

##### map的构造函数

我们通常用如下方法构造一个map：

`map<int, string> mapStudent;`

##### map的基本操作函数：

```
   begin()     返回指向map头部的迭代器

   clear(）    删除所有元素

   count()     返回指定元素出现的次数

   empty()     如果map为空则返回true

   end()      返回指向map末尾的迭代器

   equal_range()  返回特殊条目的迭代器对

   erase()     删除一个元素

   find()     查找一个元素

   get_allocator() 返回map的配置器

   insert()    插入元素

   key_comp()   返回比较元素key的函数

   lower_bound()  返回键值>=给定元素的第一个位置

   max_size()   返回可以容纳的最大元素个数

   rbegin()    返回一个指向map尾部的逆向迭代器

   rend()     返回一个指向map头部的逆向迭代器

   size()     返回map中元素的个数

   swap()      交换两个map

   upper_bound()  返回键值>给定元素的第一个位置

   value_comp()   返回比较元素value的函数
```



### multiset（多重集）：

和集合（set）相似，然而其中的值不要求必须是唯一的（即可以有重复）。

### multimap（多重映射）：

和映射（map）相似，然而其中的键值不要求必须是唯一的（即可以有重复）。

### unordered_set

头文件：#include<unordered_set>

介绍：std::unordered_set 是基于hash表的，因此并不是顺序存储。

### unordered_map：

无序映射。

与map的不同：

**1.需要引入的头文件不同**
map: #include < map >
unordered_map: #include < unordered_map > 

**2.内部实现机理不同**
**map：** map内部实现了一个红黑树（红黑树是非严格平衡二叉搜索树，而AVL是严格平衡二叉搜索树），红黑树具有自动排序的功能，因此map内部的所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行的操作。map中的元素是按照二叉搜索树（又名二叉查找树、二叉排序树，特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值）存储的，使用中序遍历可将键值按照从小到大遍历出来。
**unordered_map:** unordered_map内部实现了一个哈希表（也叫散列表，通过把关键码值映射到Hash表中一个位置来访问记录，查找的时间复杂度可达到O(1)，其在海量数据处理中有着广泛应用）。因此，**其元素的排列顺序是无序的。**



unordered_map：

优点： 因为内部实现了哈希表，因此其查找速度非常的快
缺点： 哈希表的建立比较耗费时间
适用处：对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map



总结

```
按关键字有序保存元素
map                      关联数组；保存关键字-值对
set                      关键字即值，只保存关键字的容器
multimap                 关键字可以重复出现的map
multiset                 关键字可以重复出现的set
 
无序关联容器
unordered_map            用哈希函数组织的map，无序
unordered_set            用哈希函数组织的set，无序
unordered_multimap       哈希组织的map；关键字可以重复
unordered_multiset       哈希组织的set，关键字可以重复
```

map和multimap容器的模板都定义在map头文件中，unordered_map和unordered_multimap容器的模板都定义在unordered_map头文件中。

## **红黑树**

C++ STL中标准关联容器set, multiset, map, multimap内部采用的就是一种非常高效的平衡检索二叉树：红黑树，也称为RB树(Red-Black Tree)。RB树的统计性能要好于一般的平衡二叉树，所以被STL选择作为了关联容器的内部结构。

### 为什么用红黑树实现？

map, set底层都提供了排序功能，红黑树形式存储的键值是有序的。同时**红黑树可以在O(log n)时间内做插入，查找和删除。**

### **为何map和set的插入删除效率要比其他序列容器高？**

简单来说，因为对于关联容器而言，不需要做内存拷贝和内存移动。map和set容器内的所有元素都是以节点方式来存储的，其节点结构和链表类似，指向父节点和子节点。

因此，在插入的时候只需要稍作变换，把节点的指针指向新的节点就可以了。删除的时候类似，稍作变换后吧指向删除节点的节点的指针指向其他的节点就可以了。
这其中，只涉及到指针的转换，而没有涉及到内存的移动。

### 红黑树的性质

红黑树是每个节点都带有颜色属性的二叉搜索树，颜色要么是红色，要么是黑色。

性质1：红黑树的每个节点要么是红色，要么是黑色。

性质2：红黑树的根节点一定是黑色的。

性质3：红黑树的所有外部节点都是黑色的。（外部节点是扩充二叉树中对所有空指针填充的节点）

性质4：红黑树的所有红色节点的两个子节点一定是黑色节点。（这就保证了红黑树从根到外部节点的任一条路径上都不会有两个连续的红色节点）

性质5：红黑树从根到任意一个外部节点的路径上的黑色节点的数目都是相同的。

### HashMap和TreeMap底层实现的不同

C++中unordered_map的底层是用哈希表来实现的，通过key的哈希路由到每一个桶（即数组）用来存放内容。通过key来获取value的时间复杂度就是O（1）。因为key的哈希容易碰撞，所以需要对碰撞做处理。unordered_map里的每一个数组（桶）里面存的其实是一个链表，key的哈希冲突以后会加到链表的尾部，这是再通过key获取value的时间复杂度就变成O(n），当碰撞很多的时候查询就会变慢。为了优化这个时间复杂度，map的底层就把这个链表转换成了红黑树，这样虽然插入增加了复杂度，但提高了频繁哈希碰撞时的查询效率，使查询效率变成O(log n)。

### **为什么使用红黑树而不是二叉搜索树？**

二叉搜索树并不一定是一颗平衡树，二叉搜索树（BST）只是左子树的值一定小于根节点，而右子树的值一定大于根节点。如果插入的值是有序的，那么构造出来的二叉树将是一个链表，它的时间复杂度将达到O(n)。而使用红黑树，可以通过对每个节点标色的方式，每次更新数据后进行平衡，保证查找效率。

### 左旋，右旋操作

红黑树在插入数据时要保持它的平衡需要进行着色处理，配合左旋，右旋来保持它的平衡。可以认为红色和黑色是为了更好地辅助平衡。平衡的操作如下：首先，新插入的节点必须是红色。因为黑色破坏性质的可能性更大。实现平衡的公式如下：

假定X是新插入的节点，P是父节点，Y是叔父节点，G是祖父节点，P是G的左孩子

当Y为红色->P，Y变黑，G变红，X变G

当Y为黑色，X是右孩子->左旋P，X变P

当Y为黑色，X为左孩子->G变红，P变黑，右旋G

当P为G的右孩子，直接做镜像操作就可以。

最直观的图形理解：

https://blog.csdn.net/mclongyi/article/details/103176628?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161685459816780255291135%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=161685459816780255291135&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-103176628.first_rank_v2_pc_rank_v29_10&utm_term=%E5%B7%A6%E6%97%8B+%E5%8F%B3%E6%97%8B&spm=1018.2226.3001.4187

一个红黑树插入节点的实例可以参考：https://blog.csdn.net/mxway/article/details/29216199?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2

