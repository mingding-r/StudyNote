# 数据库知识

## 索引

在关系数据库中，*索引*是一种单独的、物理的对数据库表中一列或多列的值进行排序的一种存储结构。个人理解，索引是用来增加查询效率的。

如果不使用索引，要进行全表扫描才可以实现数据的查询，对于一个较大的表或者相对复杂的查询条件而言，时间都非常长。

### 索引的分类

索引只是为了加速查询，只要是能增加查询速度的都可以作为索引。

- Hash索引

  哈希索引是很常见的一种加速，查询效率是O(1)，缺点是没有办法对范围查询进行优化。K-V型数据库就是类似的思路，加速查询。

- 平衡二叉查找树

  二叉查找树就是左子树<节点<右子树的二叉树，理想情况下二叉查找树的查询效率是O(logn)。

  二叉查找树的查询效率依赖于它的结构，有可能退化为单链表，查找效率退化到O(n)。

  广义的平衡二叉树就是考虑到这种情况，而对二叉树的结构进行限制，要求二叉查找树必须满足一些性质，例如左右子树高度差不能太大等等。

### AVL和B-Tree

严格意义的二叉平衡树是要求左右子树高度差不能大于1，这样二叉查找树在查询情况下尽可能平衡，耗时最短。二叉查找树通过在插入和删除的时候旋转节点来达到平衡高度的结果。

旋转是二叉树的一种特殊操作。右旋操作的效果是让节点N的左节点L代替N的位置，N作为L的右节点，N的左子树改为L的右子树。

旋转操作的目的是在尽可能少改变二叉树结构的情况下重新平衡一颗二叉树。右旋之后L原本所在左子树高度减少，N原本右子树R高度增加。

#### B树 

B树就是多路平衡查找树，允许一个节点记录M-1个值，每两个值之间拥有一路，所以一个节点最多有M路，即M路二叉树。

B树的特点是从下向上生长。假如有一个节点在插入之后不满足M路的性质，就把中间值提取出来放到上层节点，分裂出的两个节点就作为新的两路。如果上层节点经过这个操作也不满足了，就接着分裂，直到满足。

因为B树是从下往上生长的，它总是平衡的。

#### 红黑树

2-3树是最简单的B树，也就是3路B树。

对于一个3-节点，（有两个值和三个子树），如果将左值作为右值的左子树，前两个子树给新的左节点，最后一个子树给右值的右节点，就可以转换为一个二叉树。

如果我们认为右->左这条二叉树链接不算高度，那么就可以认为这个二叉树还是平衡的。

红黑树和2-3树是等价的，红黑树的红节点就是红链接指向的节点，黑节点就是2-3树的实际节点。红黑树的红节点平衡性质和2-3树的平衡性质是等价的。

红黑树是一种不严格的平衡二叉树实现，它将节点定义为红色和黑色两种。

通过约定

1. 节点可以是红色或者黑色
2. 根节点和叶子结点必须是黑色
3. 红节点的两个子节点必须都为黑色（不能连续红色）
4. 任何一个节点到每个叶子的简单路径都包含同样数目的黑色节点

红黑树保证了最长路径最多是最短路径的两倍（考虑完全没有红色和有一倍的红色），也算是O(logn)的时间复杂度。

红黑树在插入删除的时候不一定需要旋转，可能只需要染色。插入节点一定是红色，这样不会破坏性质4，然后再看满不满足性质3，如果不满足就考虑重新染色，然后向上递归处理。

#### B+树

B+树是对B树的一种改进，所有的值都存储在叶子结点，且叶子结点之间构成一个循环链表，能增加全表扫描效率。

### 联合索引

在`PostgreSQL`中也存在联合索引。联合索引对于多字段联合查询效率更高。

单纬度索引加上后，优化器有可能先用单维索引，反倒增加步骤，结果时间反而增加。

## 数据库基础

### ACID原则

#### Atom原子性

一个事务只能全部成功或者全部失败

#### Consistency一致性

事务不能破坏一致性，比如用户扣款100，则就应该到账VIP

#### Isolation 隔离性

不同事务之间应该互不干扰

#### **Deterministic持久性**

只要事务完成就要能持久化，必须落盘。如果挂了，日志恢复。

### 一致性问题：

为了提高并发事务的高效处理，我们选择了舍弃一部分隔离性来换取性能。但这样同时导致了一致性问题。

如：脏写、脏读、不可重复读、幻读。（排序为严重程度）

#### 脏写：

即一个事务修改了另一个未提交事务修改过的数据。（影响最严重，各个隔离级别都不允许这种情况发生）

#### 脏读：

即一个事务读到了另一个未提交事务修改过的数据。

#### 不可重复读：

即一个事务修改了另一个未提交事务读取的数据。

#### 幻读：

即一个事务查询未提交的数据被另一个事务插入了一条/多条满足查询条件的数据。

### 隔离级别：

即被舍弃的隔离性程度，级别越低越可能发生更严重的问题。以下为隔离级别由低到高介绍：

#### 读未提交 Read Uncommited

未提交的事务影响的数据也可以被读取，这会造成**脏读**：事务A修改了变量但是还没提交，这个时候事务B读取就会得到脏数据。如果A提交了就无事发生，如果A回滚了B就凉凉。

#### 读已提交Read Commited

假如只能读取已提交的事务结果，就不会造成脏读。

但是如果一个很长的事务B反复查询一个数值，这个事务过程中事务A修改了这个数值并提交，这就会导致事务B读到的数值不可重复读。

#### 可重复读Repeatable Read

MySQL的默认隔离级别是可重复读。

可重复读通常通过快照来实现，多版本并发控制MVCC，每次都读当时的值即可。

即使可以重复读，也可能造成幻读。不可重复读针对一个值，幻读针对一组记录。比如查询满足条件的行数，事务过程中别的事务提交了新的记录，多次查询行数就不同。幻读不能通过MVCC解决。

同时还有可能出现写偏差，写偏差是指逻辑上查询数据和写入数据有关联，并发状态下可能会导致写偏差：因为读写时间的差异导致写入数据的时读取条件已经改变。例如抢票。

#### 可串行化

串行化是最严格的控制，串行之后一定不会出现上面的问题，只需要保证事务内部的一致性。串行化比较慢，影响效率，通常会对其作出妥协。

**隔离级别与可能发生的现象：**

| 隔离级别       | 脏读   | 不可重复读 | 幻读   |
| -------------- | ------ | ---------- | ------ |
| 读未提交（RU） | 可能   | 可能       | 可能   |
| 读已提交（RC） | 不可能 | 可能       | 可能   |
| 可重复读（RR） | 不可能 | 不可能     | 可能   |
| 可串行化       | 不可能 | 不可能     | 不可能 |

## MyISAM与InnoDB 的区别

1. InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务； 

2. InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败； 

3. InnoDB是聚集索引，使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。

       MyISAM是非聚集索引，也是使用B+Tree作为索引结构，索引和数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。
       
       也就是说：InnoDB的B+树主键索引的叶子节点就是数据文件，辅助索引的叶子节点是主键的值；而MyISAM的B+树主键索引和辅助索引的叶子节点都是数据文件的地址指针。
   4. InnoDB不保存表的具体行数，执行select count(\*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快

   5. Innodb不支持全文索引，而MyISAM支持全文索引，在涉及全文索引领域的查询效率上MyISAM速度更快高；PS：5.7以后的InnoDB支持全文索引了

   6. MyISAM表格可以被压缩后进行查询操作

   7. InnoDB支持表、行(默认)级锁，而MyISAM支持表级锁

          InnoDB的行锁是实现在索引上的，而不是锁在物理行记录上。潜台词是，如果访问没有命中索引，也无法使用行锁，将要退化为表锁。

   8、InnoDB表必须有唯一索引（如主键）（用户没有指定的话会自己找/生产一个隐藏列Row_id来充当默认主键），而Myisam可以没有

   9、Innodb存储文件有frm、ibd，而Myisam是frm、MYD、MYI

           Innodb：frm是表定义文件，ibd是数据文件
       
           Myisam：frm是表定义文件，myd是数据文件，myi是索引文件
   如何选择：
       1. 是否要支持事务，如果要请选择innodb，如果不需要可以考虑MyISAM；

       2. 如果表中绝大多数都只是读查询，可以考虑MyISAM，如果既有读也有写，请使用InnoDB。
       
       3. 系统奔溃后，MyISAM恢复起来更困难，能否接受；
       
       4. MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的，如果你不知道用什么，那就用InnoDB，至少不会差。
   

**InnoDB为什么推荐使用自增ID作为主键？**

  **答：自增ID可以保证每次插入时B+索引是从右边扩展的，可以避免B+树和频繁合并和分裂（对比使用UUID）。如果使用字符串主键和随机主键，会使得数据随机插入，效率比较差。**

**innodb引擎的4大特性**

​    **插入缓冲（insert buffer),二次写(double write),自适应哈希索引(ahi),预读(read ahead)**

## 你了解的索引算法？

## 介绍一下乐观锁和悲观锁

1.Mysql语句（不会···）

2.索引类型和聚簇索引的主键叶子结点存的什么

3.布隆过滤器（不会···）