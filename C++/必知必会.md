# C++篇

## 1.语法

### new/delete与malloc/free的区别

​	1.new/delete会调用构造/析构函数，malloc/free则不会

​	2.new/delete无需显式给出分配的内存大小，malloc/free则需要显式给出

​	3.new/delete是操作符，可以重载，malloc/free是库函数，无法重载。

​	4.malloc返回类型为void*,必须强制类型转换对应类型指针，new则直接返回对应类型指针

|        特征        |              new/delete               |             malloc/free              |
| :----------------: | :-----------------------------------: | :----------------------------------: |
|   分配内存的位置   |              自由存储区               |                  堆                  |
| 内存分配失败返回值 |             完整类型指针              |                void*                 |
| 内存分配失败返回值 |             默认抛出异常              |               返回NULL               |
|   分配内存的大小   |       由编译器根据类型计算得出        |          必须显式指定字节数          |
|      处理数组      |       有处理数组的new版本new[]        | 需要用户计算数组的大小后进行内存分配 |
|  已分配内存的扩充  |            无法直观地处理             |         使用realloc简单完成          |
|    是否相互调用    | 可以，看具体的operator new/delete实现 |             不可调用new              |
| 分配内存时内存不足 | 客户能够指定处理函数或重新制定分配器  |       无法通过用户代码进行处理       |
|      函数重载      |                 允许                  |                不允许                |
| 构造函数与析构函数 |                 调用                  |                不调用                |

### 指针与引用的区别

★相同点：

●都是地址的概念；

指针指向一块内存，它的内容是所指内存的地址；而引用则是某块内存的别名。

★不同点：

1. 引用必须被初始化，但是不分配存储空间。指针不声明时初始化，在初始化的时候需要分配存储空间。
2. 引用初始化后不能被改变，指针可以改变所指的对象。
3. **不存在指向空值的引用，但是存在指向空值的指针**。

●指针是一个实体，而引用仅是个别名；

●引用只能在定义时被初始化一次，之后不可变；指针可变；引用“从一而终”，指针可以“见异思迁”；

**●引用不能为空，指针可以为空**；

●“**sizeof 引用**”得到的是所指向的变量(对象)的大小，而“**sizeof 指针**”得到的是指针本身的大小；

●指针和引用的自增(++)运算意义不一样；

●引用是类型安全的，而指针不是 (引用比指针多了类型检查）

### **时间/空间复杂度**

时间复杂度：

> 反映当数据量变化时，操作次数的多少;时间复杂度在评估时，要只保留最高项，并且不要最高项的系数。

空间复杂度：

> 是指算法在计算机内执行时，所需额外开辟的空间。

常数项：

> 与N的大小无关的操作。

### public,protected,private访问规则

第一：**private, public, protected访问标号的访问范围。**

private：只能由1.该类中的函数、2.其友元函数访问。

不能被任何其他访问，该类的对象也不能访问。

protected：可以被1.该类中的函数、2.子类的函数、以及3.其友元函数访问。

但不能被该类的对象访问。

public：可以被1.该类中的函数、2.子类的函数、3.其友元函数访问，也可以由4.该类的对象访问。

 

注：友元函数包括3种：设为友元的普通的非成员函数；设为友元的其他类的成员函数；设为友元类中的所有成员函数。

第二：**类的继承后方法属性变化。**

private属性不能够被继承。

使用private继承，父类的protected和public属性在子类中变为private；
使用protected继承，父类的protected和public属性在子类中变为protected；
使用public继承，父类中的protected和public属性不发生改变;

如下所示：

|               | public    | protected | private |
| ------------- | --------- | --------- | ------- |
| public继承    | public    | protected | 不可用  |
| protected继承 | protected | protected | 不可用  |
| private继承   | private   | private   | 不可用  |

protected继承和private继承能降低访问权限。

### 浅拷贝和深拷贝的区别？

#### 拷贝对象不包含引用

 -如果拷贝的对象里的元素只有值，没有引用，那浅拷贝和深拷贝没有差别

都会将原有对象复制一份，产生一个新对象，对新对象里的值进行修改不会影响原有对象，新对象和原对象完全分离开。

#### 拷贝对象包含引用

 -如果拷贝的对象里的元素包含引用，那浅拷贝和深拷贝是不同的。

浅拷贝虽然将原有对象复制一份，但是依然保存的是引用，所以对新对象里的引用里的值进行修改，依然会改变原对象里的列表的值，新对象和原对象完全分离开并没有完全分离开。

而深拷贝则不同，它会将原对象里的引用也新创建一个，即新建一个列表，然后放的是新列表的引用，这样就可以将新对象和原对象完全分离开。

### C++空类中有哪些默认的函数？

1.构造函数

2.拷贝构造函数

3.析构函数

4.赋值操作符重载函数

5.取地址操作符重载函数

6.const修饰的取地址操作符重载函数

### i++是原子操作么？

[int i =1 是原子操作吗？i++是原子操作吗？_JMW1407的博客-CSDN博客](https://blog.csdn.net/JMW1407/article/details/108318960)

**i=1是原子操作；**（cpu将立即数1搬运到变量a的内存地址）

**i++、++i、a=b都不是原子操作；**

i++分为三个阶段：在cpu执行时

- 第一步，先将 count所在内存的值加载到寄存器；
- 第二步，将寄存器的值自增1；
- 第三步，将寄存器中的值写回内存。

a=b时是先将b的值放入寄存器，再从寄存器写会a，都可以中断。


## 关键字

### static

#### c++static关键字的作用

c/c++共有

1）：修饰全局变量时，表明一个全局变量只对定义在同一文件中的函数可见。   

2）：修饰局部变量时，表明该变量的值不会因为函数终止而丢失。              

3）：修饰函数时，表明该函数只在同一文件中调用。                      

c++独有：

 4）：修饰类的数据成员，表明对该类所有对象这个数据成员都只有一个实例。即该实例归 所有对象共有。

 5）：用static修饰不访问非静态数据成员的类成员函数。这意味着一个静态成员函数只能访问它的参数、类的静态数据成员和全局变量

#### **static的优势：**

​        可以节省内存，因为它是所有对象所公有的，因此，对多个对象来说，静态数据成员只存储一处，供所有对象共用。静态数据成员的值对每个对象都是一样，但它的值是可以更新的。只要对静态数据成员的值更新一次，保证所有对象存取更新后的相同的值，这样可以提高时间效率。



### const

#### **1、定义常量**

(1)const修饰变量，变量value是不可变的。

#### **2、指针使用CONST**

(1)指针本身是常量不可变
char* const pContent;

(2)指针所指向的内容是常量不可变
const char *pContent;

(3)两者都不可变
const char* const pContent;

#### **3、函数中使用CONST**

(1)const修饰函数参数
a.传递过来的参数在函数内不可以改变(无意义，因为Var本身就是形参)

void function(const int Var);

b.参数指针所指内容为常量不可变

void function(const char* Var);

c.参数指针本身为常量不可变(也无意义，因为char* Var也是形参)

void function(char* const Var);

d.参数为引用，为了增加效率同时防止修改。修饰引用参数时：

void function(const Class& Var); //引用参数在函数内不可以改变

void function(const TYPE& Var); //引用参数在函数内为常量不可变

(2)const 修饰函数返回值
const修饰函数返回值其实用的并不是很多，它的含义和const修饰普通变量以及指针的含义基本相同。

#### **4、类相关CONST**

(1)const修饰成员变量
const修饰类的成员函数，表示成员常量，不能被修改，同时它只能在初始化列表中赋值。

(2)const修饰成员函数

a. const成员函数不被允许修改它所在对象的任何一个数据成员。

b. const成员函数能够访问对象的const成员，而其他成员函数不可以。

(3)const修饰类对象/对象指针/对象引用

· const修饰类对象表示该对象为常量对象，其中的任何成员都不能被修改。对于对象指针和对象引用也是一样。

· const修饰的对象，该对象的任何非const成员函数都不能被调用，因为任何非const成员函数会有修改成员变量的企图。


#### const与#define的区别

（1）就起作用的阶段而言： #define是在编译的预处理阶段起作用，而const是在 编译、运行的时候起作用。
（2）就起作用的方式而言： #define只是简单的字符串替换，没有类型检查。而const有对应的数据类型，是要进行判断的，可以避免一些低级的错误。 
（3）就存储方式而言：#define只是进行展开，有多少地方使用，就替换多少次，它定义的宏常量在内存中有若干个备份；const定义的只读变量在程序运行过程中只有一份备份。
（4）从代码调试的方便程度而言： const常量可以进行调试的，define是不能进行调试的，因为在预编译阶段就已经替换掉了。

### volatile



### extern



## 内存管理

c++内存分为代码区，常量区，全局静态区，堆区，栈区

| 代码区     | 常量区                      | 数据段（全局静态区） | 堆区                     | 栈区                                                         |
| :--------- | :-------------------------- | :------------------- | :----------------------- | :----------------------------------------------------------- |
| 程序的代码 | 字符串， 全局常量，静态常量 | 全局变量，静态变量   | 供程序申请（new/malloc） | 函数调用时的实参；函数的返回地址；auto变量及auto常量；局部变量 |
| 大小固定   | 大小固定                    | 大小固定             | 动态/自由分配            | 通常固定1M/2M                                                |



### 堆（heap）

由new和malloc进行动态内存分配。

### 栈（stack）

存放局部变量，函数参数，函数返回值等

#### 堆和栈的区别

主要的区别由以下几点：

  1、管理方式不同；（编译器自动管理；程序员控制）

  2、空间大小不同；（1M；4G）

  3、能否产生碎片不同；（不会；会）

  4、生长方向不同；（自上而下；自下而上）

  5、分配方式不同；

  6、分配效率不同；

## 面向对象

三个基本特征：封装、继承、多态。

### 封装



### 继承

　基类与派生类的关系
　　任何一个类都可以派生出一个新类，派生类也可以再派生出新类，因此，基类和派生类是相对而言的。
　　基类与派生类之间的关系可以有如下几种描述：

  　　1. 派生类是基类的具体化
       类的层次通常反映了客观世界中某种真实的模型。在这种情况下，不难看出：基类是对若干个派生类的抽象，而派生类是基类的具体化。基类抽取了它的派生类的公共特征，而派生类通过增加行为将抽象类变为某种有用的类型。
       
   2. 派生类是基类定义的延续

      先定义一个抽象基类，该基类中有些操作并未实现。然后定义非抽象的派生类，实现抽象基类中定义的操作。例如，虚函数就属此类情况。这时，派生类是抽象的基类的实现，即可看成是基类定义的延续。这也是派生类的一种常用方法。

   3. 派生类是基类的组合

      在多继承时，一个派生类有多于一个的基类，这时派生类将是所有基类行为的组合

      派生类将其本身与基类区别开来的方法是添加数据成员和成员函数。因此，继承的机制将使得在创建新类时，只需说明新类与已有类的区别，从而大量原有的程序代码都可以复用，所以有人称类是“可复用的软件构件”。

  

### 多态

多态就是同一事物在不同场景下的不同形态。

关于多态，简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。

多态分为静态多态、动态多态。静态多态又包括函数重载和泛型编程。动态多态即虚函数。

#### 静态多态

静态多态又包括函数重载和泛型编程。

静态多态是编译器**在编译期间完成**的，编译器会根据实参类型来选择调用合适的函数，如果有合适的函数可以调用就调，没有的话就会发出警告或者报错。（编译时决议）

#### 动态多态：

动态多态即虚函数。

我们把经过虚表调用虚函数的过程称为动态绑定，其表现出来的现象称为运行时多态。动态绑定区别于传统的函数调用，传统的函数调用我们称之为静态绑定，即函数的调用在编译阶段就可以确定下来了。

显然这和静态多态是一组反义词，它是在**程序运行时**根据基类的引用（指针）指向的对象来确定自己具体该调用哪一个类的虚函数。（运行时决议）

动态多态的条件： 
●**基类中必须包含虚函数，并且派生类中一定要对基类中的虚函数进行重写。** 
●**通过基类对象的指针或者引用调用虚函数。**

重写 ： 
（a）基类中将被重写的函数必须为虚函数 （其派生类中与其同名同参的函数不需要加virtual也是虚函数）
（b）基类和派生类中虚函数的原型必须保持一致（返回值类型，函数名称以及参数列表），协变和析构函数（基类和派生类的析构函数是不一样的）除外 
（c）访问限定符可以不同 
那么问题又来了，什么是协变？ 
协变：基类（或者派生类）的虚函数返回基类（派生类）的指针（引用） 



#### 多态缺陷

●降低了程序运行效率（多态需要去找虚表的地址） 
●空间浪费

#### 重载与重写的区别

**重载overload：**在同一个类中，函数名相同，参数列表不同（函数的参数个数、参数类型或参数顺序三者中必须至少有一种不同），函数返回值的类型可以相同，也可以不相同。发生在一个类内部，不能跨作用域。

编译器会根据这些函数的不同参数列表，将同名的函数名称做修饰，从而生成一些不同名称的预处理函数

 

**重写override：**也叫覆盖，子类重新定义父类中有相同名称相同参数的虚函数，主要是在继承关系中出现的，被重写的函数必须是virtual的，重写函数的访问修饰符可以不同，尽管virtual是private的，子类中重写函数改为public,protected也可以，体现了多态。

 

**重定义redefining：**也叫隐藏，子类重新定义父类中有相同名称的非虚函数，参数列表可以相同可以不同，会覆盖其父类的方法，可以理解成发生在继承中的重载。//是否体现了多态？

a如果派生类的函数和基类的函数同名，但是参数不同，此时，不管有无virtual，基类的函数被隐藏。

b如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有vitual关键字，此时，基类的函数被隐藏。（如果有virtual就成重写了）
**区别**

|      | 重载               | 重写         |
| ---- | ------------------ | ------------ |
|      | 静态多态           | 动态多态     |
|      | 编译时             | 运行时       |
|      | 一个类中           | 子类与父类间 |
|      | 不同参数列表       | 相同参数列表 |
|      | 不能只有返回值不同 | 返回值相同   |

重载实现的是编译时的多态性，重写实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的参数列表，有兼容的返回类型。

#### 虚函数

C++中的虚函数的作用主要是实现了多态的机制。基类定义虚函数，子类可以重写该函数；在派生类中对基类定义的虚函数进行重写时，需要在派生类中声明该方法为虚方法。

一个类函数的调用并不是在编译时刻被确定的，而是在运行时刻被确定的。由于编写代码的时候并不能确定被调用的是基类的函数还是哪个派生类的函数，所以被成为“虚”函数。

虚函数只能借助于指针或者引用来达到多态的效果。

当子类重新定义了父类的虚函数后，**当父类的指针指向子类对象的地址时**，父类指针根据赋给它的不同子类指针，动态的调用子类的该函数，而不是父类的函数

且这样的函数调用发生在运行阶段，而不是发生在编译阶段，称为动态联编。而函数的重载可以认为是多态，只不过是静态的。注意，非虚函数静态联编，效率要比虚函数高，但是不具备动态联编能力。

//如果使用了**virtual**关键字，程序将根据引用或指针指向的 **对 象 类 型** 来选择方法，否则使用**引用类型或指针类型**来选择方法。

##### 虚函数的底层实现机制 

**实现原理：虚函数表+虚表指针**

[C++ 虚函数表 vfptr_好记性不如烂笔头-CSDN博客](https://blog.csdn.net/yc461515457/article/details/52658589?ops_request_misc=%7B%22request%5Fid%22%3A%22161918781116780269813183%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=161918781116780269813183&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-52658589.first_rank_v2_pc_rank_v29&utm_term=虚函数表&spm=1018.2226.3001.4187)

同一个类的不同实例共用同一份虚函数表, 她们都通过一个所谓的虚函数表指针__vfptr(定义为void**类型)指向该虚函数表.

编译器处理虚函数的方法是：
给每个对象添加一个指针，存放了指向虚函数表的地址，虚函数表存储了为类对象进行声明的虚函数地址。比如基类对象包含一个指针，该指针指向基类所有虚函数的地址表，派生类对象将包含一个指向独立地址表的指针，如果派生类提供了虚函数的新定义，该虚函数表将保存新函数的地址，如果派生类没有重新定义虚函数，该虚函数表将保存函数原始版本的地址。如果派生类定义了新的虚函数，则该函数的地址将被添加到虚函数表中，注意虚函数无论多少个都只需要在对象中添加一个虚函数表的地址。

调用虚函数时，程序将查看存储在对象中的虚函数表地址，转向相应的虚函数表，使用类声明中定义的第几个虚函数，程序就使用数组的第几个函数地址，并执行该函数。

**使用虚函数后的变化：**
（1）	对象将增加一个存储地址的空间（32位系统为4字节，64位为8字节）。
（2）	每个类编译器都创建一个虚函数地址表
（3）	对每个函数调用都需要增加在表中查找地址的操作。

**虚函数的注意事项：**

总结前面的内容
（1） 基类方法中声明了方法为虚后，该方法在基类派生类中是虚的。
（2） 若使用指向对象的引用或指针调用虚方法，程序将根据对象类型来调用方法，而不是指针的类型。
（3）如果定义的类被用作基类，则应将那些要在派生类中重新定义的类方法声明为虚。

##### 析构函数可以使用虚函数么？

**基类的析构函数应该为虚函数。**（在实现多态时，当用基类操作派生类，在析构时防止只析构基类而不析构派生类的状况发生，以免造成内存泄露）

如果派生类没有重定义函数，则会使用基类版本。
重新定义继承的方法若和基类的方法不同（协变除外），会将基类方法隐藏；如果基类声明方法被重载，则派生类也需要对重载的方法重新定义，否则调用的还是基类的方法。

 如果没有继承或不需要基类对派生类及对象进行操作,则不能定义虚函数,因为这样会增加内存开销（因为添加了虚函数表存虚函数指针）

##### **那些函数不能定义为虚函数？** 

1）友元函数，它不是类的成员函数 
2）全局函数 
3）静态成员函数，它没有this指针 
3）构造函数，拷贝构造函数，以及赋值运算符重载（可以但是一般不建议作为虚函数）

##### 纯虚函数

**纯虚函数**是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0”
　virtual void funtion1()=0
**原因：**为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。在很多情况下，基类本身生成对象是不合情理的。

在成员函数(必须为虚函数)的形参列表后面写上=0，则成员函数为**纯虚函数**。

**包含纯虚函数的类叫做抽象类**（也叫接口类），抽象类不能实例化出对象。纯虚函数在派生类中重新定义以后，派生类才能实例化出对象。纯虚函数是一定要被继承的，否则它存在没有任何意义。

定义一个函数为虚函数，不代表函数为不被实现的函数。

定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。

定义一个函数为纯虚函数，才代表函数没有被实现。

定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。

## C++11

### 智能指针

为了更容易(同时也更安全)地使用动态内存，C++11标准库提供了两种智能指针(smart pointer)类型来管理动态对象。智能指针的行为类似常规指针，**重要的区别是它负责自动释放所指的对象**。C++11标准库提供的这两种智能指针的区别在于管理底层指针的方式：shared_ptr允许多个指针指向同一个对象；unique_ptr则"独占"所指向的对象。C++11标准库还定义了一个名为weak_ptr的辅助类，它是一种弱引用，指向shared_ptr所管理的对象。这三种类型都定义在**memory头文件**中。智能指针是模板类而不是指针。

**C++开发处理内存泄漏最有效的办法就是使用智能指针**，使用智能指针就不会担心内存泄露的问题了，**因为智能指针可以自动删除分配的内存。**

智能指针是指向动态分配(堆)对象指针，用于生存期控制，能够确保自动正确的销毁动态分配的对象，防止内存泄露。**它的一种通用实现技术是使用引用计数。每次使用它，内部的引用计数加1，每次析构一次，内部引用计数减1，减为0时，删除所指向的堆内存。**


#### shared_ptr

shared_ptr基于”引用计数”模型实现，多个shared_ptr可指向同一个动态对象，并维护一个共享的引用计数器，记录了引用同一对象的shared_ptr实例的数量。当最后一个指向动态对象的shared_ptr销毁时，会自动销毁其所指对象(通过delete操作符)。

缺点：循环引用会导致内存泄漏，解决方式为weak_ptr;

#### weak_ptr

weak_ptr被设计为与shared_ptr共同工作，可以从一个shared_ptr或者另一个weak_ptr对象构造，获得资源的观测权。但weak_ptr没有共享资源，它的构造不会引起指针引用计数的增加。同样，在weak_ptr析构时也不会导致引用计数的减少，它只是一个静静地观察者。weak_ptr没有重载operator*和->，这是特意的，因为它不共享指针，不能操作资源，这是它弱的原因。但它可以使用一个非常重要的成员函数lock()从被观测的shared_ptr获得一个可用的shared_ptr对象，从而操作资源。

#### unique_ptr

unique_ptr 是 C++ 11 提供的用于防止内存泄漏的智能指针中的一种实现，独享被管理对象指针所有权的智能指针。unique_ptr对象包装一个原始指针，并负责其生命周期。当该对象被销毁时，会在其析构函数中删除关联的原始指针。
unique_ptr具有->和*运算符重载符，因此它可以像普通指针一样使用。



**C++11中的右值引用、转移语义和完美转发**

## STL

### vector

#### vector中的resize，reserve的区别

1. reserve()只修改capacity大小，不修改size大小，
2. resize()既修改capacity大小，也修改size大小。



### map



### unordered_map





## 模板



这里首先说下语言基础知识，一些关键字和实现原理等：

- 指针、引用、数组、内存
- C和 C++ 的一些区别，比如 new、delete 和 malloc、free 的区别
- C++中引用与指针区别
- 继承、虚继承、菱形继承等
- C++虚机制：虚函数、虚函数表、纯虚函数
- 多态： 动态绑定，静态多态
- C++里一些关键字的作用：static、const、volatile、extern
- C++ 重写、重载
- 智能指针使用：shared_ptr、weak_ptr、unique_ptr等
- 类型转换：static_cast, dynamic_cast, const_cast, reinterpret_cast
- STL大部分容器的实现原理，如 vector、deque、map、hashmap
- 模板特化、偏特化，萃取 traits 技巧
- 程序编译链接机制、内存布局（memory layout）、对象模型
- C++11 部分新特性，比如右值引用、完美转发等
- 智能指针原理：引用计数、RAII（资源获取即初始化）思想
- C++构造、析构、移动、拷贝等
- C++ 内存管理，堆、栈、指针、野指针、内存泄露等
- 内联函数、宏定义区别等





# 操作系统篇

## 操作系统的组成

1.什么是操作系统？ 

(1)计算机硬件与用户软件之间的中间件程序集合

 (2)OS是一个资源管理程序

 (3)OS是一个控制调度程序

 (4)OS一般有一个内核（kernel)程序，开机后一直运行

 (5)提供用户和计算机之间的接口

2.现代操作系统的五大组成部分：**进程管理、存储管理、文件管理、设备管理、系统调用**

3.操作系统的四个基本特征：**并发性，共享性，虚拟性，不确定性 （异步性）**

4.分时操作系统的基本特征：交互性、多用户同时性、独立性，及时性

## 进程线程

### 进程线程的区别

进程是操作系统分配资源的基本单位，线程是CPU调度的基本单位

进程的资源是独享的，线程是共享的进程的资源。

进程崩了不影响别的进程，线程崩了会导致同进程的线程的都崩掉

进程创建，切换，终止的开销大，线程小

进程之间的通信更复杂，线程通信相对容易



数据需要隔离时选进程，数据需要共享时选线程。

多进程适用于CPU密集型，多线程适用于I//O密集型（切换开销小）

### 进程间通信方式

**管道通信，共享内存，消息队列，信号量，信号，套接字socket；**

#### 共享内存（Shared Memory）

它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等

特点：

1)共享内存是最快的一种IPC，因为进程是直接对内存进行存取

2)因为多个进程可以同时操作，所以需要进行同步

3)信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问

**共享内存的实现方式？**

**同一块物理内存被映射到进程A、B各自的进程地址空间。**进程A可以即时看到进程B对共享内存中数据的更新，反之亦然。由于多个进程共享同一块内存区域，必然需要某种同步机制，互斥锁和信号量都可以。

**为什么共享内存最快？**

因为进程可以直接读写内存，而不需要任何数据的拷贝。对于像管道和消息队列等通信方式，则需要在内核和用户空间进行四次的数据拷贝，而共享内存则只拷贝两次数据[1]：一次从输入文件到共享内存区，另一次从共享内存区到输出文件。

消息队列和管道基本上都是4次拷贝，而共享内存（mmap, shmget）只有两次。
4次：1，由用户空间的buf中将数据拷贝到内核中。2，内核将数据拷贝到内存中。3，内存到内核。4，内核到用户空间的buf.
2次： 1，用户空间到内存。 2，内存到用户空间。

#### socket

涉及的函数有：Bind() ，Listen()，accept ()，send()，receive()，connect()，close();

### 线程间通信方式

#### **锁机制**：

包括互斥锁、条件变量、读写锁

##### 互斥锁：

提供了以排他方式防止数据结构被并发修改的方法。

##### 读写锁：

允许多个线程同时共享数据，而对写操作是互斥的。

##### 条件变量：

可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。

条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：

​					一个线程因等待"条件变量的条件成立"而挂起；
​					另外一个线程使"条件成立"，给出信号，从而唤醒被等待的线程。
为了防止竞争，条件变量的使用总是和一个互斥锁结合在一起；通常情况下这个锁是std::mutex，并且管理这个锁 只能是 std::unique_lock<std::mutex> RAII模板类。

上面提到的两个步骤，分别是使用以下两个方法实现：

​			等待条件成立使用的是condition_variable类成员wait 、wait_for 或 wait_until。
​			给出信号使用的是condition_variable类成员notify_one或者notify_all函数。
在生产者消费者问题中，条件变量可以保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据。

总结一下条件变量的几个关键点：

\1. wait()函数的内部实现是：先释放了互斥量的锁，然后阻塞以等待条件为真；
\2. notify系列函数需在unlock之后再被调用；
\3. 套路是：
    a. A线程拿住锁，然后wait,此时已经释放锁，只是阻塞了在等待条件为真；
    b. B线程拿住锁，做一些业务处理，然后令条件为真，释放锁，再调用notify函数；
    c. A线程被唤醒，接着运行。

#### **信号量机制（Semaphore）**：

包括无名进程信号量和命名线程信号量

#### **信号机制（Signal）**：

类似进程间的信号处理

#### 信号量与条件变量的区别？

（1）使用条件变量可以一次唤醒所有等待者，而这个信号量没有的功能，感觉是最大区别。

（2）信号量是有一个值（状态的），而条件变量是没有的，没有地方记录唤醒（发送信号）过多少次，也没有地方记录唤醒线程（wait返回）过多少次。从实现上来说一个信号量可以是用mutex + counter + condition variable（互斥锁+计数器+条件变量）实现的。因为信号量有一个状态，如果想精准的同步，那么信号量可能会有特殊的地方。信号量可以解决条件变量中存在的唤醒丢失问题。

（3）在Posix.1基本原理一文声称，有了互斥锁和条件变量还提供信号量的原因是：“本标准提供信号量的而主要目的是提供一种进程间同步的方式；这些进程可能共享也可能不共享内存区。互斥锁和条件变量是作为线程间的同步机制说明的；这些线程总是共享(某个)内存区。这两者都是已广泛使用了多年的同步方式。每组原语都特别适合于特定的问题”。尽管信号量的意图在于进程间同步，互斥锁和条件变量的意图在于线程间同步，但是信号量也可用于线程间，互斥锁和条件变量也可用于进程间。应当根据实际的情况进行决定。信号量最有用的场景是用以指明可用资源的数量。

### 协程

在有大量IO操作业务的情况下，我们采用协程替换线程，可以到达很好的效果，一是降低了系统内存，二是减少了系统切换开销，因此系统的性能也会提升。

在协程中尽量不要调用阻塞IO的方法，比如打印，读取文件，Socket接口等，除非改为异步调用的方式，并且协程只有在IO密集型的任务中才会发挥作用。

**协程只有和异步IO结合起来才能发挥出最大的威力。**



协程在io操作比较多，且IO是瓶颈的地方才有用。

首先协程算是用户态的线程，**优势主要是少了内核态用户态的切换和能自己来做调度**。
然后协程一般只在有IO操作的时候才能用到，对于一些会阻塞的IO操作，可以自己选择协程切换，等IO就绪了再切回来，可以更充分利用CPU。

## 内存缓存

## 缓冲溢出的影响

 缓冲区溢出是指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上。

 危害有以下两点：

   1、程序崩溃，导致拒绝服务

   2、跳转并且执行一段恶意代码

   原因：造成缓冲区溢出的主要原因是程序中没有仔细检查用户输入。



## 死锁

在并发环境中，各进程欣慰资源竞争而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法继续进行的现象。

### 死锁产生的条件：

1.互斥

2.不可剥夺

3.请求保持

4.循环等待

### 避免死锁的方式：

1.预防死锁：破坏死锁的必要条件

2.避免死锁：如银行家算法（分配资源前先判断一下分配后是否会造成系统处于不安全状态，不会则分配，会则拒绝）

3.死锁的检测和解除

检测：

死锁定理：如果某时刻系统的资源分配图是不可完全简化的，那么此时系统死锁。

解除：

-资源剥夺法；

-撤销进程法

-进程回退法；

另外，系统处于不安全状态未必死锁，但死锁时一定处于不安全状态，系统处于安全状态一定不会死锁。

## 中断

### 中断分类

#### 外部中断

**1.可屏蔽中断**：**通过INTR线向CPU请求的中断**，主要来自外部设备如硬盘，打印机，网卡等。此类中断并不会影响系统运行，可随时处理，甚至不处理，所以名为可屏蔽中断。

**2.不可屏蔽中断**：**通过INTR线向CPU请求的中断**，主要来自外部设备如硬盘，打印机，网卡等。此类中断并不会影响系统运行，可随时处理，甚至不处理，所以名为可屏蔽中断。

#### 内部中断（软中断）

**1.陷阱**：**是一种有意的，预先安排的异常事件**，一般是在编写程序时故意设下的陷阱指令，而后执行到陷阱指令后，CPU将会调用特定程序进行相应的处理，**处理结束后返回到陷阱指令的下一条指令**。

如**系统调用**，程序调试功能等。

**2.故障**：**故障是在引起故障的指令被执行，但还没有执行结束时，CPU检测到的一类的意外事件。**出错时交由故障处理程序处理，**如果能处理修正这个错误，就将控制返回到引起故障的指令即CPU重新执这条指令。如果不能处理就报错。**

常见的故障如 **缺页**

**3.终止**：**执行指令的过程中发生了致命错误，不可修复，程序无法继续运行，只能终止，通常会是一些硬件的错误。**终止处理程序不会将控制返回给原程序，而是直接终止原程序。

![image-20210416163832980](image-20210416163832980.png)

## 文件管理

生产者消费者模型

共享内存是怎么实现的？（mmap?)

fork()之后两进程之间修改后结果 取地址后结果

1.什么是用户态内核态

2.进程线程的使用选择（场景）

3.线程锁的类型

4.锁锁的什么？

5.给我一个必死锁的场景，最简单的那种



- 并发经典的问题：读者写者、哲学家就餐问题
- 文件系统是如何组织的
- 互斥与同步（信号量、管程、锁）
- 死锁检测与避免
- 虚拟文件系统（VFS）是如何抽象的
- 线程的实现方式（一对一、多对一等）
- 为什么需要虚拟内存，MMU 具体如何做地址转换的
- 内存为什么分段、分页
- 页面置换算法
- 进程的状态、切换、调度

对于进程、线程这块你还可以把 fork、vfork、clone 、pthread_create 这些模块关系彻底搞清楚，对你理解 Linux 下的进程实现有非常大的帮助。



# 计算机网络篇

## TCP/IP

## HTTP/HTTPS

## SSL加密过程

SSL英文全称Secure Socket Layer，安全套接层，是一种为网络通信提供安全以及数据完整性的安全协议，它在传输层对网络进行加密。它主要是分为两层：

​	-SSL记录协议：为高层协议提供安全封装、压缩、加密等基本功能
​	-SSL握手协议：用于在数据传输开始前进行通信双方的身份验证、加密算法的协商、交换密钥

SSL加密

过程：

1.利用非对称加密使客户端得到服务端的公钥（数字证书）；

2.利用服务端公钥协商对称加密的私钥；

3.利用对称加密传输数据；



数字证书的验证过程

第一步 ：客户端A开启一个新的浏览器访问客户端时，会先让A安装一个数字证书，这个证书主要包含的是CA机构的公钥。
第二步：服务端B发来CA机构给自己的证书，通过CA公钥解密被CA私钥加密的hash1，然后再用B的证书里面的hash算法将信息生成一个hash2，通过比较两个hash，若相等，确认这个数字证书是服务端B的。
![image-20210426165506569](image-20210426165506569.png)

SSL握手过程：

第一步 客户端A给出 支持的SSL版本+一个随机数+自己支持的加密方式
第二步 服务端B接收到这些信息后确认加密方式+自己的安全证书+一个随机数发给A
第三步 客户端A确认数字证书有效性（验证方法上面已经说明），然后生成一个随机数，并将这个随机数用B的数字证书公钥加密后发送给A。
第四步 服务端B使用自己的私钥解密这个随机数
第五步 A和B通过第二步确定的加密方法将前三个随机数生成一个对话密钥 用来接下来的通信（个人感觉不需要三个随机数，只用最后一个就够了，这样做可能是为了更安全）

![img](20180921165828285)



需要掌握的网络协议和知识：

- HTTP、TCP、IP、ICMP、UDP、DNS、ARP
- IP地址、MAC地址、OSI七层模型（或者 TCP/IP 五层模型）
- 常见网络攻击：局域网ARP泛洪、DDoS、TCP SYN Flood、XSS等
- HTTPS安全相关的：数字签名、数字证书、TLS
- HTTP常见返回码含义，HTTP1.0、2.0区别等

TCP的重点知识：

- 三次握手、四次挥手
  
- 建立、断开连接过程中状态转换
  
- TCP 状态中 TIME_WAIT
  
- 拥塞控制
  
- 快速重传、慢启动等
  
- TCP重发机制，Nagle算法
  

**学习过程中也要多思考为什么要这么设计，这里列几个问题：**

- TCP 如何实现可靠传输的（画外音：如何基于 UDP 实现可靠传输
- 第二次和第三次之间的等待是什么
- TCP 连接建立为什么不是两次握手（画外音：三次握手的充分必要性说明
- TIME_WAIT 的存在解决了什么问题，等待时间为什么是 2 MSL
- 为什么不是四次握手

**常见端口与服务：**

21 : FTP - 文件传输协议 - TCP

23 : TELNET - 远程登录协议 - TCP

25 : SMTP - 简单邮件传输协议 - TCP

80 : HTTP - 超文本传输协议 - TCP

53 : DNS - 域名系统 - UDP

**最后别忘了自己复述一遍那被问烂了、写烂了的问题：**

- **从 URL 输入到页面展现到底发生什么？**

HTTP 和 HTTPS：

- HTTP中GET/POST的区别
- 常见的状态码：1XX、2XX、3XX、4XX
- HTTP/HTTPS的区别，证书、数字签名等原理
- COOKIE/SESSION的区别

**但是计网中还是有一些有意思的问题，如果你没思考过，也许回答不出来。**

比如：

- 为什么有了 MAC 地址还要 IP 地址，IP 地址和 MAC 地址的区别是什么？
- 如何理解广播域和冲突域？
- 路由器和交换机有什么区别？
- TCP 连接的本质是什么，真的是“链接”吗？（曾经被问过：Java socket 创建的 TCP 连接，对于主机挂了和 JVM 挂了有什么区别？

# 数据库篇

## 事务

## 锁

## 内存引擎



## 外/内连接；左右连接

[左连接 ，右连接，内连接和全外连接的4者区别_灰太狼-CSDN博客_左连接](https://blog.csdn.net/weixin_39220472/article/details/81193617?ops_request_misc=%7B%22request%5Fid%22%3A%22161942836916780357254775%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=161942836916780357254775&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-5-81193617.first_rank_v2_pc_rank_v29&utm_term=左连接%2C右连接%2C内连接%2C外连接的区别&spm=1018.2226.3001.4187)

​		left join （左连接）：返回包括左表中的所有记录和右表中连接字段相等的记录。
　　right join （右连接）：返回包括右表中的所有记录和左表中连接字段相等的记录。
　　inner join （等值连接或者叫内连接）：只返回两个表中连接字段相等的行。
　　full join （全外连接）：返回左右表中所有的记录和左右表中连接字段相等的记录。





整个数据库最重要的还是索引和并发控制（锁、MVCC等），这部分也是面试常考的：

- 索引存储结构：B树、B+树索引、Hash索引
  
- 索引的使用：主键索引、覆盖索引、最左前缀原则、索引下推等
  
- 锁：乐观锁、悲观锁、表锁，行锁，意向锁，读锁，写锁等等
  
- MySQL InnoDB MVCC 实现机制
  
- 存储引擎：InnoDB、MyISAM等，各自的优缺点
  
- 事务：ACID理论





# 网络编程篇

## I/O复用

### 阻塞I/O

### 非阻塞I/O

### I/O多路复用

#### select和epoll的区别

select的结构是数组；epoll是红黑树加链表；

select的时间复杂度是o(n)；epoll的时间复杂度o(1)；

select支持的最大连接数为1024；epoll无最大连接数的上限；

select消息传递需要内核拷贝；epoll消息传递通过共享内存；

#### 什么情况下select比epoll好？

1、表面上看epoll的性能最好，但是**在连接数少并且连接都十分活跃的情况下**，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。

2、select低效是因为每次它都需要轮询。但低效也是相对的，视情况而定，也可通过良好的设计改善 

### 信号驱动I/O

### 异步I/O

## 多线程



重点知识：

Linux 下网络编程核心的包括网络 IO 和系统编程两个部分：

- 进程间通信方式： 信号量、管道、共享内存、socket 等
- 五大 IO 模型：同步、异步、阻塞、非阻塞、信号驱动
- 高性能 IO 两种模式：Reactor 和 Proactor（ 但是 Linux 下由于缺少异步 IO 支持，基本没有 Proactor
- IO 复用机制：epoll、select、poll（破解 C10K 问题的利器）
- 多线程编程：互斥锁、条件变量、读写锁、线程池等





# 数据结构与算法篇

## 栈和队列

### 栈和队列的区别？

栈与队列的相同点：

1.都是线性结构（线性表）。

2.插入操作都是限定在表尾进行。

3.都可以通过顺序结构和链式结构实现。、

4.插入与删除的时间复杂度都是O（1），在空间复杂度上两者也一样。

5.多链栈和多链队列的管理模式可以相同。

栈与队列的不同点：

1.删除数据元素的位置不同，栈的删除操作在表尾进行，队列的删除操作在表头进行。

2.应用场景不同；常见栈的应用场景包括括号问题的求解，表达式的转换和求值，函数调用和递归实现，深度优先搜索遍历等；常见的队列的应用场景包括计算机系统中各种资源的管理，消息缓冲器的管理和广度优先搜索遍历等。

3.顺序栈能够实现多栈空间共享，而顺序队列不能。

4.**栈先进后出，队列先进先出**

## 红黑树



## B+树



## **跳表**

[数据结构-----跳表_一个程序渣渣的小后院-CSDN博客_跳表](https://blog.csdn.net/sinat_35261315/article/details/62890796?ops_request_misc=%7B%22request%5Fid%22%3A%22161943943516780271514064%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=161943943516780271514064&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-7-62890796.first_rank_v2_pc_rank_v29&utm_term=跳表&spm=1018.2226.3001.4187)

结合链表和二分法的特点，将链表进行加工，创造一个二者的结合体：
1.链表从头节点到尾节点是有序的
2.可以进行跳跃查找（形如二分法）

## 排序算法

### 复杂度





![image-20210407183627817](image-20210407183627817.png)

### 适用场景

设待排序元素的个数为n.
1）当n较大，则应采用时间复杂度为O(nlgn)的排序方法：快速排序、堆排序或归并排序。

​	 快速排序：是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的						平均时间最短；
 	堆排序 ：  N过大时堆排序可解决快排的递归层数过多问题。
 	归并排序：如果内存空间允许且要求稳定性的，它有一定数量的数据移动，所以我们可能过与插入排序组合，						先获得一定长度的序列，然后再合并，在效率上将有所提高。

2） 当n较大，内存空间允许，且要求稳定性 ——归并排序
3）当n较小，可采用直接插入或直接选择排序。

​	直接插入排序：当元素分布有序，直接插入排序将大大减少比较次数和移动记录的次数。 

​	直接选择排序 ：元素分布有序，如果不要求稳定性，选择直接选择排序

5）一般不使用或不直接使用传统的冒泡排序。

6）基数排序
它是一种稳定的排序算法，但有一定的局限性：
　　1、关键字可分解。
　　2、记录的关键字位数较少，如果密集更好
　　3、如果是数字时，最好是无符号的，否则将增加相应的映射复杂度，可先将其正负分开排序。

### 快排



### 归并排序



### 数组中第K大的数

1.介绍各个排序算法的时间复杂度、空间复杂度

2.快排实现原理 快排空间复杂度如何优化（讲逻辑）

3.求第K大的数怎么实现（讲逻辑） 



重点数据结构：

- 线性表、数组、链表
- 栈与队列
- 散列函数和散列表
- 树、二叉树、多叉树实现和遍历方式，AVL树实现以及插入删除过程、红黑树（了解定义即可）
- 图，以及图的实现方式、遍历
- 堆
- B树、B+树
- 。。。

常见的算法：

- 排序算法：冒泡、插入、堆排、基数、快速、希尔、归并等
- 字符串匹配算法：KMP
- 常见算法思想：递推、分治、贪心、递归、枚举、动态规划等





