# C++篇

## 1.语法

#### new/delete与malloc/free的区别

​	1.new/delete会调用构造/析构函数，malloc/free则不会

​	2.new/delete无需显式给出分配的内存大小，malloc/free则需要显式给出

​	3.new/delete是操作符，可以重载，malloc/free是库函数，无法重载。

​	4.malloc返回类型为void*,必须强制类型转换对应类型指针，new则直接返回对应类型指针

|        特征        |              new/delete               |             malloc/free              |
| :----------------: | :-----------------------------------: | :----------------------------------: |
|   分配内存的位置   |              自由存储区               |                  堆                  |
| 内存分配失败返回值 |             完整类型指针              |                void*                 |
| 内存分配失败返回值 |             默认抛出异常              |               返回NULL               |
|   分配内存的大小   |       由编译器根据类型计算得出        |          必须显式指定字节数          |
|      处理数组      |       有处理数组的new版本new[]        | 需要用户计算数组的大小后进行内存分配 |
|  已分配内存的扩充  |            无法直观地处理             |         使用realloc简单完成          |
|    是否相互调用    | 可以，看具体的operator new/delete实现 |             不可调用new              |
| 分配内存时内存不足 | 客户能够指定处理函数或重新制定分配器  |       无法通过用户代码进行处理       |
|      函数重载      |                 允许                  |                不允许                |
| 构造函数与析构函数 |                 调用                  |                不调用                |

#### 指针与引用的区别

★相同点：

●都是地址的概念；

指针指向一块内存，它的内容是所指内存的地址；而引用则是某块内存的别名。

★不同点：

1. 引用必须被初始化，但是不分配存储空间。指针不声明时初始化，在初始化的时候需要分配存储空间。
2. 引用初始化后不能被改变，指针可以改变所指的对象。
3. **不存在指向空值的引用，但是存在指向空值的指针**。

●指针是一个实体，而引用仅是个别名；

●引用只能在定义时被初始化一次，之后不可变；指针可变；引用“从一而终”，指针可以“见异思迁”；

**●引用不能为空，指针可以为空**；

●“**sizeof 引用**”得到的是所指向的变量(对象)的大小，而“**sizeof 指针**”得到的是指针本身的大小；

●指针和引用的自增(++)运算意义不一样；

●引用是类型安全的，而指针不是 (引用比指针多了类型检查）

### **时间/空间复杂度**

时间复杂度：

> 反映当数据量变化时，操作次数的多少;时间复杂度在评估时，要只保留最高项，并且不要最高项的系数。

空间复杂度：

> 是指算法在计算机内执行时，所需额外开辟的空间。

常数项：

> 与N的大小无关的操作。

#### public,protected,private访问规则

第一：**private, public, protected访问标号的访问范围。**

private：只能由1.该类中的函数、2.其友元函数访问。

不能被任何其他访问，该类的对象也不能访问。

protected：可以被1.该类中的函数、2.子类的函数、以及3.其友元函数访问。

但不能被该类的对象访问。

public：可以被1.该类中的函数、2.子类的函数、3.其友元函数访问，也可以由4.该类的对象访问。

 

注：友元函数包括3种：设为友元的普通的非成员函数；设为友元的其他类的成员函数；设为友元类中的所有成员函数。

第二：**类的继承后方法属性变化。**

private属性不能够被继承。

使用private继承，父类的protected和public属性在子类中变为private；
使用protected继承，父类的protected和public属性在子类中变为protected；
使用public继承，父类中的protected和public属性不发生改变;

如下所示：

|               | public    | protected | private |
| ------------- | --------- | --------- | ------- |
| public继承    | public    | protected | 不可用  |
| protected继承 | protected | protected | 不可用  |
| private继承   | private   | private   | 不可用  |

protected继承和private继承能降低访问权限。


## 关键字

#### static

##### c++static关键字的作用

c/c++共有

1）：修饰全局变量时，表明一个全局变量只对定义在同一文件中的函数可见。   

2）：修饰局部变量时，表明该变量的值不会因为函数终止而丢失。              

3）：修饰函数时，表明该函数只在同一文件中调用。                      

c++独有：

 4）：修饰类的数据成员，表明对该类所有对象这个数据成员都只有一个实例。即该实例归 所有对象共有。

 5）：用static修饰不访问非静态数据成员的类成员函数。这意味着一个静态成员函数只能访问它的参数、类的静态数据成员和全局变量

**static的优势：**

​        可以节省内存，因为它是所有对象所公有的，因此，对多个对象来说，静态数据成员只存储一处，供所有对象共用。静态数据成员的值对每个对象都是一样，但它的值是可以更新的。只要对静态数据成员的值更新一次，保证所有对象存取更新后的相同的值，这样可以提高时间效率。

**静态局部变量**

静态局部变量属于静态存储方式，它具有以下特点：

(1)静态局部变量 在函数内定义它的生存期为 整个程序生命周期，但是其 作用域仍与 自动变量相同 ，只能在定义该变量的函数内使用该变量。退出该函数后，尽管该变量还继续存在，但不能使用它。

(2)对基本类型的静态局部变量若在声明时未赋以初值，则系统自动赋予0值 。

**静态全局变量**

全局变量本身就是静态存储方式，静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同。
这两者的区别在于：

(1).非静态全局变量 的作用域是整个源程序 ，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。

(2). 而静态全局变量 则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于 一个源文件内 ，只能为该源文件内的函数公用， 因此可以避免在其它源文件中引起错误。

从以上分析可以看出，把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围 **static 函数**

**静态函数**    

 如果在一个源文件中定义的函数，只能被本文件中的函数调用，而不能被同一程序其它文件中的函数调用，这种函数称为static函数与称为静态函数。

内部函数又称静态函数。但此处“static”的含义不是指存储方式，而是指对函数的作用域仅局限于本文件 。

使用内部函数的好处是：不同的人编写不同的函数时，不用担心自己定义的函数，是否会与其它文件中的函数同名，因为同名也没有关系。

**static 数据成员**

在类内数据成员的声明前加上关键字static，该数据成员就是类内的静态数据成员。

static数据成员有以下特点：

(1). 对于非static数据成员，每个类对象都有自己的拷贝。而static数据成员被当作是类的成员。无论这个类的对象被定义了多少个，静态数据成员在程序中也只有一份拷贝 ，由该类型的所有对象共享访问。也就是说，静态数据成员是该类的所有对象所共有的。对该类的多个对象来说，静态数据成员只分配一次内存，供所有对象共用。

   (2). 静态数据成员存储在全局数据区。静态数据成员定义时才分配空间，所以不能在类声明中定义。在上例中，语句int Test::m_nSTest1= 10;是定义静态数据成员；

   (3). 静态数据成员和普通数据成员一样遵从public,protected,private访问规则；

   (4). 因为静态数据成员在全局数据区分配内存，属于本类的所有对象共享，所以，它不属于特定的类对象，在没有产生类对象时其作用域就可见，即在没有产生类的实例时，我们就可以操作它；

   (5). 静态数据成员初始化与一般数据成员初始化不同。静态数据成员初始化的格式为：＜数据类型＞＜类名＞::＜静态数据成员名＞=＜值＞ 如：int Test::m_nSTest1 = 10;

(6). 类的静态数据成员有两种访问形式：＜类对象名＞.＜静态数据成员名＞ 或 ＜类类型名＞::＜静态数据成员名＞

(7). 静态数据成员主要用在各个对象都有相同的某项属性的时候。比如对于一个存款类，每个实例的利息都是相同的。所以，应该把利息设为存款类的静态数据成员。这有两个好处，第一，不管定义多少个存款类对象，利息数据成员都共享分配在全局数据区的内存，所以节省存储空间。第二，一旦利息需要改变时，只要改变一次，则所有存款类对象的利息全改变过来了；

(8). 同全局变量相比，使用静态数据成员有两个优势：

a. 静态数据成员没有进入程序的全局名字空间，因此不存在与程序中其它全局名字冲突的可能性；

b. 可以实现信息隐藏。静态数据成员可以是private成员，而全局变量不能；

**static成员函数**

关于静态成员函数，可以总结为以下几点：

(1). 出现在类体外的函数定义不能指定关键字static ；

(2). static成员之间可以相互访问 ，包括static成员函数访问static数据成员和访问static成员函数；

(3). 非静态成员函数可以任意地访问静态成员函数和静态数据成员；

(4). 静态成员函数不能访问非静态成员函数和非静态数据成员，只能访问静态的；

(5). 由于没有this指针的额外开销，因此静态成员函数与类的全局函数相比速度上会有少许的增长；

(6). 调用静态成员函数，可以用成员访问操作符(.)和(->)为一个类的对象或指向类对象的指针调用静态成员函数，也可以直接使用如下格式：

＜类名＞::＜静态成员函数名＞（＜参数表＞）

如：Test::PrintStatic()，调用类的静态成员函数。

但是，一样要遵从public,protected,private访问规则。

#### const

**1、定义常量**
(1)const修饰变量，变量value是不可变的。

**2、指针使用CONST**
(1)指针本身是常量不可变
char* const pContent;

(2)指针所指向的内容是常量不可变
const char *pContent;

(3)两者都不可变
const char* const pContent;

**3、函数中使用CONST**

(1)const修饰函数参数
a.传递过来的参数在函数内不可以改变(无意义，因为Var本身就是形参)

void function(const int Var);

b.参数指针所指内容为常量不可变

void function(const char* Var);

c.参数指针本身为常量不可变(也无意义，因为char* Var也是形参)

void function(char* const Var);

d.参数为引用，为了增加效率同时防止修改。修饰引用参数时：

void function(const Class& Var); //引用参数在函数内不可以改变

void function(const TYPE& Var); //引用参数在函数内为常量不可变

(2)const 修饰函数返回值
const修饰函数返回值其实用的并不是很多，它的含义和const修饰普通变量以及指针的含义基本相同。

**4、类相关CONST**

(1)const修饰成员变量
const修饰类的成员函数，表示成员常量，不能被修改，同时它只能在初始化列表中赋值。

(2)const修饰成员函数

a. const成员函数不被允许修改它所在对象的任何一个数据成员。

b. const成员函数能够访问对象的const成员，而其他成员函数不可以。

(3)const修饰类对象/对象指针/对象引用

· const修饰类对象表示该对象为常量对象，其中的任何成员都不能被修改。对于对象指针和对象引用也是一样。

· const修饰的对象，该对象的任何非const成员函数都不能被调用，因为任何非const成员函数会有修改成员变量的企图。


##### const与#define的区别

（1）就起作用的阶段而言： #define是在编译的预处理阶段起作用，而const是在 编译、运行的时候起作用。
（2）就起作用的方式而言： #define只是简单的字符串替换，没有类型检查。而const有对应的数据类型，是要进行判断的，可以避免一些低级的错误。 
（3）就存储方式而言：#define只是进行展开，有多少地方使用，就替换多少次，它定义的宏常量在内存中有若干个备份；const定义的只读变量在程序运行过程中只有一份备份。
（4）从代码调试的方便程度而言： const常量可以进行调试的，define是不能进行调试的，因为在预编译阶段就已经替换掉了。

#### volatile



#### extern



## 内存管理

c++内存分为代码区，常量区，全局静态区，堆区，栈区

#### 堆（heap）

由new和malloc进行动态内存分配。

#### 栈（stack）

存放局部变量，函数参数，函数返回值等

##### 堆和栈的区别

主要的区别由以下几点：

  1、管理方式不同；（编译器自动管理；程序员控制）

  2、空间大小不同；（1M；4G）

  3、能否产生碎片不同；（不会；会）

  4、生长方向不同；（自上而下；自下而上）

  5、分配方式不同；

  6、分配效率不同；

## 面向对象

#### 继承

#### 派生

　基类与派生类的关系
　　任何一个类都可以派生出一个新类，派生类也可以再派生出新类，因此，基类和派生类是相对而言的。
　　基类与派生类之间的关系可以有如下几种描述：

  　　1. 派生类是基类的具体化
       类的层次通常反映了客观世界中某种真实的模型。在这种情况下，不难看出：基类是对若干个派生类的抽象，而派生类是基类的具体化。基类抽取了它的派生类的公共特征，而派生类通过增加行为将抽象类变为某种有用的类型。
        　　2. 派生类是基类定义的延续
       先定义一个抽象基类，该基类中有些操作并未实现。然后定义非抽象的派生类，实现抽象基类中定义的操作。例如，虚函数就属此类情况。这时，派生类是抽象的基类的实现，即可看成是基类定义的延续。这也是派生类的一种常用方法。
                 　　3. 派生类是基类的组合
       在多继承时，一个派生类有多于一个的基类，这时派生类将是所有基类行为的组合。
       　　派生类将其本身与基类区别开来的方法是添加数据成员和成员函数。因此，继承的机制将使得在创建新类时，只需说明新类与已有类的区别，从而大量原有的程序代码都可以复用，所以有人称类是“可复用的软件构件”。

#### 多态



## C++11

#### 智能指针

为了更容易(同时也更安全)地使用动态内存，C++11标准库提供了两种智能指针(smart pointer)类型来管理动态对象。智能指针的行为类似常规指针，**重要的区别是它负责自动释放所指的对象**。C++11标准库提供的这两种智能指针的区别在于管理底层指针的方式：shared_ptr允许多个指针指向同一个对象；unique_ptr则"独占"所指向的对象。C++11标准库还定义了一个名为weak_ptr的辅助类，它是一种弱引用，指向shared_ptr所管理的对象。这三种类型都定义在**memory头文件**中。智能指针是模板类而不是指针。

**C++开发处理内存泄漏最有效的办法就是使用智能指针**，使用智能指针就不会担心内存泄露的问题了，**因为智能指针可以自动删除分配的内存。**

智能指针是指向动态分配(堆)对象指针，用于生存期控制，能够确保自动正确的销毁动态分配的对象，防止内存泄露。**它的一种通用实现技术是使用引用计数。每次使用它，内部的引用计数加1，每次析构一次，内部引用计数减1，减为0时，删除所指向的堆内存。**


##### shared_ptr

shared_ptr基于”引用计数”模型实现，多个shared_ptr可指向同一个动态对象，并维护一个共享的引用计数器，记录了引用同一对象的shared_ptr实例的数量。当最后一个指向动态对象的shared_ptr销毁时，会自动销毁其所指对象(通过delete操作符)。

缺点：循环引用会导致内存泄漏，解决方式为weak_ptr;

##### weak_ptr

weak_ptr被设计为与shared_ptr共同工作，可以从一个shared_ptr或者另一个weak_ptr对象构造，获得资源的观测权。但weak_ptr没有共享资源，它的构造不会引起指针引用计数的增加。同样，在weak_ptr析构时也不会导致引用计数的减少，它只是一个静静地观察者。weak_ptr没有重载operator*和->，这是特意的，因为它不共享指针，不能操作资源，这是它弱的原因。但它可以使用一个非常重要的成员函数lock()从被观测的shared_ptr获得一个可用的shared_ptr对象，从而操作资源。

##### unique_ptr

unique_ptr 是 C++ 11 提供的用于防止内存泄漏的智能指针中的一种实现，独享被管理对象指针所有权的智能指针。unique_ptr对象包装一个原始指针，并负责其生命周期。当该对象被销毁时，会在其析构函数中删除关联的原始指针。
unique_ptr具有->和*运算符重载符，因此它可以像普通指针一样使用。

## STL

## 模板



这里首先说下语言基础知识，一些关键字和实现原理等：

- 指针、引用、数组、内存
- C和 C++ 的一些区别，比如 new、delete 和 malloc、free 的区别
- C++中引用与指针区别
- 继承、虚继承、菱形继承等
- C++虚机制：虚函数、虚函数表、纯虚函数
- 多态： 动态绑定，静态多态
- C++里一些关键字的作用：static、const、volatile、extern
- C++ 重写、重载
- 智能指针使用：shared_ptr、weak_ptr、unique_ptr等
- 类型转换：static_cast, dynamic_cast, const_cast, reinterpret_cast
- STL大部分容器的实现原理，如 vector、deque、map、hashmap
- 模板特化、偏特化，萃取 traits 技巧
- 程序编译链接机制、内存布局（memory layout）、对象模型
- C++11 部分新特性，比如右值引用、完美转发等
- 智能指针原理：引用计数、RAII（资源获取即初始化）思想
- C++构造、析构、移动、拷贝等
- C++ 内存管理，堆、栈、指针、野指针、内存泄露等
- 内联函数、宏定义区别等





# 操作系统篇

## 操作系统的组成

1.什么是操作系统？ 

(1)计算机硬件与用户软件之间的中间件程序集合

 (2)OS是一个资源管理程序

 (3)OS是一个控制调度程序

 (4)OS一般有一个内核（kernel)程序，开机后一直运行

 (5)提供用户和计算机之间的接口

2.现代操作系统的五大组成部分：进程管理、存储管理、文件管理、设备管理、系统调用

3.操作系统的四个基本特征：并发性，共享性，虚拟性，不确定性 （异步性）

4.分时操作系统的基本特征：交互性、多用户同时性、独立性，及时性

## 进程线程

#### 进程线程的区别

进程是操作系统分配资源的基本单位，线程是CPU调度的基本单位

进程的资源是独享的，线程是共享的进程的资源。

进程崩了不影响别的进程，线程崩了会导致同进程的线程的都崩掉

进程创建，切换，终止的开销大，线程小

进程之间的通信更复杂，线程通信相对容易



多进程适用于CPU密集型，多线程适用于I//O密集型（切换开销小）

#### 进程间通信方式

**管道通信，共享内存，消息队列，信号量，信号，套接字socket；**

##### 共享内存（Shared Memory）

它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等

特点：

1)共享内存是最快的一种IPC，因为进程是直接对内存进行存取

2)因为多个进程可以同时操作，所以需要进行同步

3)信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问

**共享内存的实现方式？**

**同一块物理内存被映射到进程A、B各自的进程地址空间。**进程A可以即时看到进程B对共享内存中数据的更新，反之亦然。由于多个进程共享同一块内存区域，必然需要某种同步机制，互斥锁和信号量都可以。

**为什么共享内存最快？**

因为进程可以直接读写内存，而不需要任何数据的拷贝。对于像管道和消息队列等通信方式，则需要在内核和用户空间进行四次的数据拷贝，而共享内存则只拷贝两次数据[1]：一次从输入文件到共享内存区，另一次从共享内存区到输出文件。

消息队列和管道基本上都是4次拷贝，而共享内存（mmap, shmget）只有两次。
4次：1，由用户空间的buf中将数据拷贝到内核中。2，内核将数据拷贝到内存中。3，内存到内核。4，内核到用户空间的buf.
2次： 1，用户空间到内存。 2，内存到用户空间。

##### socket

涉及的函数有：Bind() ，Listen()，accept ()，send()，receive()，connect()，close();

#### 线程间通信方式

**锁机制**：包括互斥锁、条件变量、读写锁

　　　　互斥锁：提供了以排他方式防止数据结构被并发修改的方法。

　　　　读写锁：允许多个线程同时共享数据，而对写操作是互斥的。

　　　　条件变量：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。

**信号量机制（Semaphore）**：包括无名进程信号量和命名线程信号量

**信号机制（Signal）**：类似进程间的信号处理

## 内存缓存

## 死锁

## 文件管理

一些复习的思路：

- 操作系统由哪些构成
- 进程和线程的区别
- 进程间通信方式（共享内存、管道、消息）
- 
- 并发经典的问题：读者写者、哲学家就餐问题
- 文件系统是如何组织的
- 互斥与同步（信号量、管程、锁）
- 死锁检测与避免
- 虚拟文件系统（VFS）是如何抽象的
- 线程的实现方式（一对一、多对一等）
- 为什么需要虚拟内存，MMU 具体如何做地址转换的
- 内存为什么分段、分页
- 页面置换算法
- 进程的状态、切换、调度

对于进程、线程这块你还可以把 fork、vfork、clone 、pthread_create 这些模块关系彻底搞清楚，对你理解 Linux 下的进程实现有非常大的帮助。



# 计算机网络篇

## TCP/IP

## HTTP/HTTPS



需要掌握的网络协议和知识：

- HTTP、TCP、IP、ICMP、UDP、DNS、ARP
- IP地址、MAC地址、OSI七层模型（或者 TCP/IP 五层模型）
- 常见网络攻击：局域网ARP泛洪、DDoS、TCP SYN Flood、XSS等
- HTTPS安全相关的：数字签名、数字证书、TLS
- HTTP常见返回码含义，HTTP1.0、2.0区别等

TCP的重点知识：

- 三次握手、四次挥手
  
- 建立、断开连接过程中状态转换
  
- TCP 状态中 TIME_WAIT
  
- 拥塞控制
  
- 快速重传、慢启动等
  
- TCP重发机制，Nagle算法
  

**学习过程中也要多思考为什么要这么设计，这里列几个问题：**

- TCP 如何实现可靠传输的（画外音：如何基于 UDP 实现可靠传输
- 第二次和第三次之间的等待是什么
- TCP 连接建立为什么不是两次握手（画外音：三次握手的充分必要性说明
- TIME_WAIT 的存在解决了什么问题，等待时间为什么是 2 MSL
- 为什么不是四次握手

**常见端口与服务：**

21 : FTP - 文件传输协议 - TCP

23 : TELNET - 远程登录协议 - TCP

25 : SMTP - 简单邮件传输协议 - TCP

80 : HTTP - 超文本传输协议 - TCP

53 : DNS - 域名系统 - UDP

**最后别忘了自己复述一遍那被问烂了、写烂了的问题：**

- **从 URL 输入到页面展现到底发生什么？**

HTTP 和 HTTPS：

- HTTP中GET/POST的区别
- 常见的状态码：1XX、2XX、3XX、4XX
- HTTP/HTTPS的区别，证书、数字签名等原理
- COOKIE/SESSION的区别

**但是计网中还是有一些有意思的问题，如果你没思考过，也许回答不出来。**

比如：

- 为什么有了 MAC 地址还要 IP 地址，IP 地址和 MAC 地址的区别是什么？
- 如何理解广播域和冲突域？
- 路由器和交换机有什么区别？
- TCP 连接的本质是什么，真的是“链接”吗？（曾经被问过：Java socket 创建的 TCP 连接，对于主机挂了和 JVM 挂了有什么区别？

# 数据库篇

## 事务

## 锁

## 内存引擎

整个数据库最重要的还是索引和并发控制（锁、MVCC等），这部分也是面试常考的：

- 索引存储结构：B树、B+树索引、Hash索引
  
- 索引的使用：主键索引、覆盖索引、最左前缀原则、索引下推等
  
- 锁：乐观锁、悲观锁、表锁，行锁，意向锁，读锁，写锁等等
  
- MySQL InnoDB MVCC 实现机制
  
- 存储引擎：InnoDB、MyISAM等，各自的优缺点
  
- 事务：ACID理论





# 网络编程篇

重点知识：

Linux 下网络编程核心的包括网络 IO 和系统编程两个部分：

- 进程间通信方式： 信号量、管道、共享内存、socket 等
- 五大 IO 模型：同步、异步、阻塞、非阻塞、信号驱动
- 高性能 IO 两种模式：Reactor 和 Proactor（ 但是 Linux 下由于缺少异步 IO 支持，基本没有 Proactor
- IO 复用机制：epoll、select、poll（破解 C10K 问题的利器）
- 多线程编程：互斥锁、条件变量、读写锁、线程池等





# 数据结构篇

## 排序算法

重点数据结构：

- 线性表、数组、链表
- 栈与队列
- 散列函数和散列表
- 树、二叉树、多叉树实现和遍历方式，AVL树实现以及插入删除过程、红黑树（了解定义即可）
- 图，以及图的实现方式、遍历
- 堆
- B树、B+树
- 。。。

常见的算法：

- 排序算法：冒泡、插入、堆排、基数、快速、希尔、归并等
- 字符串匹配算法：KMP
- 常见算法思想：递推、分治、贪心、递归、枚举、动态规划等





